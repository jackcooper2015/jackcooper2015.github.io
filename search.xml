<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Oracle课堂笔记]]></title>
    <url>%2F2018%2F03%2F19%2FOracle%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[oracle课堂笔记包含ddl，dml，tcl，游标，过程，函数，触发器等详细demo。志在帮助小白变大神 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717--创建/*create tablespace student1datafile 'E:\oracle\product\10.2.0\oradata\dafiles\student.dbf'size 10Mautoextend on*/drop table new_dept;create table newdeptas select * from scott.dept;create table salgradeas select * from scott.salgrade;--1. 创建一个学生表包含：学号、姓名、性别、年龄、出生日期等 字段。 create table student( cno number(5) not null, cname varchar(10), sex char(2), age number(2), birthday date default sysdate ) / --2、修改学生表额外添加成绩字段。alter table Student add (grade number(3,1));--2-1、给学号加上主键约束。alter table Student add constraint PK_Student_cno primary key (cno);--3、给性别加检查约束：提示 check(sex='男' or sex='女') 。alter table Student add constraint CHK_Student_sex check (sex in('男','女'));--4、年龄加检查约束，年龄在18~25之间；提示：check(age&gt;=18 and age&lt;=25)。alter table Student add constraint CHK_Student_age check (age between 18 and 25);--5、向表里插入记录来验证约束是否生效。 insert into Student values (95009,'\张三','男',25,date'2011-02-15',96); insert into Student values (95002,'李四','女',23,date'2011-02-15',97); insert into Student values (95004,'王五','男',18,date'2019-8-15',96); insert into Student values (95003,'james','女',22,date'2019-8-15',96); insert into Student values (95005,'andy','男',18,'9-12月-14',96);--6、查询出表中的所有记录。select * from Student;--7. 查询出表中的所有记录。--8. 选择部门为30中的所有员工select * from new_scott;select * from new_scott where deptno = 30 ;--9. 列出所有办事员（CLERK）的姓名，编号和部门编号select distinct ename from new_scott where job='CLERK'; --10. 找出佣金高于薪金的员工。select * from new_scott where comm&gt;sal;--11. 找出佣金高于薪金60%的员工select * from new_scott where comm&gt;(sal*0.6);--12. 找出部门10中所有的（MANAGER）和部门20中所有办事员（CLERK）。select * from new_scott where (deptno=10 and job = 'MANAGER') or (deptno = 20 and job = 'CLERK');--插入信息 INSERT into new_scott values(7347,'Bob','CLERK',7876,to_date('1999-02-15','yyyy-mm-dd'),1000,0,10);--select * from new_scott where empno = '7347';COMMIT;--提交ROLLBACK;--回滚--修改当前回话的日期格式--alter session set sysdate_formate = 'YYYY-MM-DD HH24:MI:SS';--更新update new_scott set ename = 'james' where empno = 7347; --删除delete new_scott where empno = 7347;--DCL ||||| commit:提交 rollback：回滚 savepoint ：表即可回滚的点 delete new_scott where ename = 'JONES'; savepoint mark1; update new_scott set ename = 'chengui' where empno = 7369; savepoint mark2; rollback to savepoint mark1; --链接符|| select empno||'姓名'||ename||'工作'||job||'上司'||mgr||'入职时间'||hiredate||'工资'||sal||'佣金'||comm||'部门编号'||deptno from new_scott; --like 匹配 select * from new_scott where job like '_A%'; select * from new_scott where ename like '\%' ; select ename , sal,nvl(comm,0),sal+nvl(comm,0) salary from new_scott; select * from new_scott where mgr is not null; --13. 找出收取佣金的员工的不同工作 select distinct job from new_scott where comm is not null; --14. 找出不收取佣金或收取的佣金不低于100的员工 select * from new_scott where comm is null or comm&lt;100 order by empno--15. 找出部门10中所有的（MANAGER）和部门20中所有办事员（CLERK）,--和既不是经理又不是办事员但其薪金大于或等于2000的所有员工的详细资料 select * from new_scott where (deptno = 10 and job = 'MANAGER' or deptno = 20 AND JOB = 'CLERK' ) OR (JOB NOT IN ('MANAGER','CLERK') AND SAL&gt;=2000); --16. 找出各月倒数第三天受雇的所有员工select * from new_scottwhere extract(DAY from last_day(hiredate))- extract(DAY from (hiredate))=2;select * from new_scott --17. 找出早于25年前受雇佣的员工select * from new_scott where extract(year from systimestamp)- extract(year from (hiredate))&gt;25;--18. 以首字母大写其它字母小写的方式显示所有的员工的姓名。select empno,INITCAP(LOWER(ename)),job,mgr,hiredate,sal,comm,deptno from new_scott;--以首字母小写其它字母大写的方式显示所有的员工的姓名。 --CONCAT(UPPER(substr(LOWER(ename),1,1)) , UPPER(substr(UPPER(ename),1))) select empno,CONCAT((substr(LOWER(ename),1,1)) , UPPER(substr(UPPER(ename),1))), job,mgr,hiredate,sal,comm,deptno from new_scott;--19. 显示正好为5字符的员工的姓名select ename from new_scott where LENGTH(ename)=5;--20. 显示不带有‘R’的与员工的姓名select ename from new_scott where ename not like '%R%';--21. 显示所有员工姓名的前三个字符。select SUBSTR(ename,1,3) from new_scott;--22. 显示所有员工的姓名，用 A 替换 a select TRANSLATE(ename,'A','a')from new_scott;--23. 显示 满25年 服务年限的员工的姓名 和受雇日期select ename,hiredate from new_scott where extract(year from systimestamp)- extract(year from (hiredate))&gt;25;--MONTHS_BETWEEN(sysdate,hiredate)/12&gt;25;--24. 显示员工的详细资料，按姓名排序,姓名相同按工资降序排序。select * from new_scott order by ename ,sal desc;--25. 显示与员工的姓名和受雇日期，根据其服务年限，将最老的员工排在最前面。select ename,hiredate , (extract(year from systimestamp)- extract(year from (hiredate))) time from new_scott order by time desc;--26. 显示所有员工的姓名，工作和薪金，按工作的降序排序，若工作相同按薪金排序select ename,job,sal from new_scott order by job desc,sal desc;--select * from new_scott;--decode用法（条件，属性1，值1，属性2，值2，……，默认值） select ename,decode(job,'CLERK','办事员','MANAGER','经理', 'SALESMAN','销售员','ANALYST','分析师','老板') from new_scott;--27. 显示所有员工的姓名，加入公司的年份和月份，按受雇日期所在的月排序，若月份相同，则将最早的年份的员工排在最前面select ename,to_char(hiredate,'yyyy"年"mm"月"') from new_scottorder by extract(MONTH from hiredate) ,extract(YEAR from hiredate);--经典方法select ename,job,TO_CHAR(hiredate,'yyyy')year,to_char(hiredate,'mm')month,form employee order by month,year;/*-------------------------------------------------------- 分组查询 -------------------------------------*/ --28. 显示非销售人员工作名称以及从事同一工作雇员的月工资的总和，并且要满足从事同一工作的雇员的月工资合计大于$5000，--输出结果按月工资排序。select job,sum(sal) from new_scottgroup by jobhaving sum(sal)&gt;5000order by sum(sal);--29. 查询出各部门的部门编号以及各部门的总工资和平均工资。select deptno ,to_char(sum(sal),'L999,999,999.00'),to_char(avg(sal),'L999,999,999.00')from new_scottgroup by deptno;select * from new_scott;--30. 按男生和女生统计JAVA和ORACLE成绩的总分和平均分？select sum(JAVASCORE) AS java总成绩 ,AVG(JAVASCORE) java平均成绩,SUM(ORACLESCORE)oracle总成绩 ,AVG(ORACLESCORE) Oracle平均成绩 FROM STUDENT2group by GENDER ;-- 1） 建表create table STUDENT2( STUNO CHAR(4) not null primary key, STUNAME VARCHAR2(20), GENDER CHAR(2), JAVASCORE INTEGER, ORACLESCORE INTEGER);-- 2） 插入记录INSERT INTO STUDENT2 VALUES('1000','JAMES','男',88,78);INSERT INTO STUDENT2 VALUES('1001','JACK','男',86,79);INSERT INTO STUDENT2 VALUES('1002','ANDY','女',76,78);INSERT INTO STUDENT2 VALUES('1003','SAMMY','女',77,76);INSERT INTO STUDENT2 VALUES('1004','frank','男',88,78);INSERT INTO STUDENT2 VALUES('1005','bob','男',86,79);INSERT INTO STUDENT2 VALUES('1006','july','女',76,78);INSERT INTO STUDENT2 VALUES('1007','mark','女',77,76);-- 统计成绩select stuno,stuname,javascore+oraclescore 总成绩,(javascore+oraclescore)/2 平均成绩 from STUDENT2order by 总成绩 desc;select gender,sum(javascore),avg(javascore),sum(oraclesore),avg(oraclescore) form student2 group by gender;create table newdeptas select * from scott.dept;select * from newdept;select * from new_scott;--全链接select * from newdept full join new_scott on new_scott.deptno = newdept.deptno;select * from newdept left join new_scott on new_scott.deptno = newdept.deptno;select * from newdept right join new_scott on new_scott.deptno = newdept.deptno;--coalesce(expr1,expr2,expr3,....exprn) NVL 同，前为空，则一直向后搜寻，最后默认为exprncreate table salgradeas select * from scott.salgrade;select e.* from new_scott n, salgrade s where e.sal between s.lowsal and s.hisal;select '工号为：'|| e.empno||'的员工的名字是'||e.ename||'的上司是'||temp.empno ||temp.ename from new_scott e join new_scott temp on e.mgr = temp.empno;--工资分类select e.* ,f.* from new_scott e join salgrade fon e.sal &gt;f.losal and e.sal&lt; f.hisal;create trigger tri_salgrade_insertafter inserton salgrade begin RAISE_APPLICATION_ERROR ('YOU MAY ERRROR');end; INSERT into salgrade values(6,4000,9999) --查询在‘NEW YORK’工作，工资高于2000的员工以及员工的工资等级。--方法一：select n.*,s.grade ,dept.* from new_scott n , salgrade s,newdept dept where n.deptno = dept.deptno and n.sal&gt;s.losal and n.sal&lt;s.hisal and n.sal&gt;2000 and dept.loc = 'NEW YORK'--方法二：select n.*,s.grade,dept.*from new_scott n join salgrade son n.sal&gt;s.losal and n.sal&lt;s.hisaljoin newdept depton dept.deptno = n.deptno and n.sal&gt;2000 and dept.loc like 'NEW YORK'; select n.empno,n.ename,sal,locfrom new_scott n, (select * from newdept where newdept.loc = 'NEW YORK' and deptno = 10 ) S where n.deptno = s.deptno; select * from newdept;select * from NEW_SCOTT;select * from newdept;/*-----------------------------------------------第三章 高级查询 ----------------------------------A. 查询部门在‘NEW YORK’工资低于4000，不是‘CLERK’的员工？--B. 查询部门在‘CHICAGO’，在1981年入职，工资在2000~4000的员工？/*----------------------------------------------- 子查询 -----------------------------------------子查询注意的问题： 1、要将子查询发在圆括号内。 2、子查询可出现在WHERE子句、FROM子句、SELECT列表(此处只能是一个单行子查询)、HAVING子句中。 3、子查询不能出现在主查询的GROUP BY语句中。 4、子查询和主查询使用表可以不同，是要子查询返回的结果能够被主查询使用即可。 5、一般不会在子查询中使用ORDER BY语句，但在TOP-N(只需前几条记录)分析中必须使用ORDER BY语句。 6、单行子查询只能使用单行操作符，多行子查询只能使用多行操作符。 7、采用合理的缩进和换行来提过SQL语句的可读性。 8、子查询中的空值问题。*/ --31. 查询部门名称为SALES和ACCOUNTING的员工信息/*1 7499 ALLEN SALESMAN 7698 1981/2/20 1600.00 300.00 30 30 SALES CHICAGO2 7521 WARD SALESMAN 7698 1981/2/22 1250.00 500.00 30 30 SALES CHICAGO3 7654 MARTIN SALESMAN 7698 1981/9/28 1250.00 1400.00 30 30 SALES CHICAGO4 7698 BLAKE MANAGER 7839 1981/5/1 2850.00 30 30 SALES CHICAGO5 7782 CLARK MANAGER 7839 1981/6/9 2450.00 10 10 ACCOUNTING NEW YORK6 7839 KING PRESIDENT 1981/11/17 5000.00 10 10 ACCOUNTING NEW YORK7 7844 TURNER SALESMAN 7698 1981/9/8 1500.00 0.00 30 30 SALES CHICAGO8 7900 JAMES CLERK 7698 1981/12/3 950.00 30 30 SALES CHICAGO9 7934 MILLER CLERK 7782 1982/1/23 1300.00 10 10 ACCOUNTING NEW YORK*/select * from new_scott e,newdept nwhere e.deptno = n.deptno and n.dname in ('SALES','ACCOUNTING'); --32. 查询不是经理的员工的信息(使用in 或 not in来做)/*1 7369 SMITH CLERK 7902 1980/12/17 800.00 202 7499 ALLEN SALESMAN 7698 1981/2/20 1600.00 300.00 303 7521 WARD SALESMAN 7698 1981/2/22 1250.00 500.00 304 7654 MARTIN SALESMAN 7698 1981/9/28 1250.00 1400.00 305 7844 TURNER SALESMAN 7698 1981/9/8 1500.00 0.00 306 7876 ADAMS CLERK 7788 1987/5/23 1100.00 207 7900 JAMES CLERK 7698 1981/12/3 950.00 308 7934 MILLER CLERK 7782 1982/1/23 1300.00 10*/ select * from new_scott where empno not in (select distinct mgr from new_scott where mgr is not null);--33. 查询工资比10号部门员工中任意一个低的员工信息(13) select * from new_scott e where e.sal &lt; any (select distinct sal from new_scott where deptno = 10)--34. 查询工资比10号部门都要低的员工信息 select * from new_scott e where e.sal &lt;all (select distinct sal from new_scott where deptno = 10)--35. 查询出部门名称，部门员工数，部门平均工资，部门最低工资雇员的姓名，及工资等级select n.dname,t.deptno,t.total,t.ag,t.mi,s.grade,e.enamefrom new_scott e ,salgrade s,newdept n,(select deptno, count(*) total, avg(sal) ag, min(sal) mi from new_scott group by deptno) twhere e.deptno = t.deptno and e.sal&gt;=s.losal and e.sal&lt;=s.hisal and n.deptno = e.deptno and e.sal in (select mi from (select deptno, count(*) total, avg(sal) ag, min(sal) mi from new_scott group by deptno) t) --36. 列出最低薪金大于1500的各种工作及此从事此工作的全部雇员人数/*1 ANALYST 22 MANAGER 33 PRESIDENT 1*/--方法一select distinct(e.job),t.totalfrom new_scott e,(select job ,min(sal) mi,count(*) total from new_scott group by job)twhere e.job = t.job and t.mi &gt; 1500;--方法二select e.job, count(*)人数 from emp e group by e.job having (select min(sal) from emp where e.em)--37. 求出在'salesman'部门工作的员工姓名，假设不知道销售部的部门编号select distinct e.ename from new_scott e,newdept nwhere e.deptno = (select distinct deptno from new_scott where job = UPPER('salesman'));--38. 列出薪金高于公司平均薪金的所有员工，所在部门，上级领导，公司的工资等级select e.ename,e.sal,n.dname,e.mgr,s.gradefrom new_scott e,newdept n,salgrade swhere e.sal &gt;(select avg(sal) from new_scott )and e.deptno = n.deptnoand e.sal &gt;s.losal and e.sal &lt;=s.hisal;--39. 列出于“SCOTT”从事相同工作的所有员工及部门名称select e.ename ,n.dname from new_scott e,newdept nwhere e.job = (select job from new_scott where ename = 'SCOTT') and e.deptno = n.deptno;--40. 查询和SMITH部门相同 岗位相同的人select * from new_scott e, newdept nwhere e.deptno = (select deptno from new_scott where ename = 'SMITH' ) and e.job = (select job from new_scott where ename = 'SMITH') and e.deptno = n.deptno;--41. 和ALLEN同部门，工资高于MARTIN的雇员有哪些 select * from new_scott e where e.deptno = (select deptno from new_scott where ename = 'ALLEN') and e.sal &gt; (select sal from new_scott where ename = 'ALLEN') --42. 比blake工资高的雇员有哪些? select * from new_scott e where e.sal &gt; (select sal from new_scott where ename = upper('blake')) --43. 高于30部门最高工资的雇员有哪些?select * from new_scott e where e.sal &gt; (select max(sal) from new_scott where deptno = 30)--44. 查询scott用户下的emp表中所有的经理的信息(此操作子查询会返回多行记录)select * from new_scott where empno in (select mgr from new_scott);--45. 工资高于本部门平均工资的人（拿上游工资的人）有哪些？****select e.*from new_scott ewhere e.sal &gt;(select avg(sal) from new_scott where deptno = e.deptno)select e.deptno ,e.empno,e.sal,e.ename from new_scott e,(select deptno,avg(sal) ag from new_scott group by deptno ) twhere t.deptno = e.deptno and e.sal &gt; t.aggroup by e.deptno ,e.empno,e.ename,e.sal;--46. 工作和部门与SMITH相同，工资高于JAMES的雇员有哪些?select * from new_scott e,newdept nwhere e.job = (select job from new_scott where ename = 'SMITH') and e.deptno = n.deptno and n.deptno = (select new_scott.deptno from new_scott,newdept where ename = 'SMITH' and new_scott.deptno = newdept.deptno ) and e.sal &gt;(select sal from new_scott where ename = 'JAMES');/*---------------------------------------------- 多行子查询 --------------------------------------*/--47. 列出薪金等于部门30中员工的薪金的所有员工的姓名和薪金select e.ename,e.sal from new_scott ewhere e.sal in (select sal from new_scott where deptno = 30);--48.列出薪金大于部门30中员工的薪金的所有员工的姓名和薪金select e.ename,e.sal from new_scott ewhere e.sal&gt;any (select sal from new_scott where deptno = 30);--49.列出每个部门工作的员工数量，平均工资和平均服务年限select deptno ,count(*) 员工数量 ,to_char(avg (sal),'L999,999.00'),to_char(avg(months_between(sysdate,hiredate)/12),'999.00') from new_scottgroup by deptno;select *from new_scott e,--删除没有员工的部门--方法一delete newdeptwhere deptno in (select deptno from newdept MINUS select distinct deptno from new_scott)and deptno &lt;&gt; 40;--方法二delete newdeptwhere deptno not in (select deptno from new_scott)--创建同义词：-- 1)创建私有同义词 注意：需要sys授权：grant create SYNONYM to stu;create or replace public synonym emp for new_scott ;-- 2）创建共有同义词 注意：需要sys授权：grant create public SYNONYM to stu;create public synonym dept1 for newdept;--drop public synonym dept;--创建序列：create sequence emp_seq start with 8002 increment by 1 minvalue 8002 maxvalue 999999999999 cycle cache 20--select emp_seq.nextval from emp_seq;--执行emp_seq.currval 之前一定要执行一次 emp_seq.nextvalselect emp_seq.currval from dual; commit; drop sequence emp_seq;insert into emp(empno,ename,job,mgr,deptno)values(emp_seq.nextval ,'james','CLERK',7698,20)--创建视图create view emp_viewas select * from emp; select * from emp_view;--删除视图drop view emp_view;select empno,ename,dname from emp e,newdept d where e.deptno = d.deptno AND e.ename&lt;&gt;'SCOTT' AND e.job=(select job from emp where ename='SCOTT');--创建索引create index emp_job on emp(job);--验证索引select * from emp where job = upper('salesman');--第一个小例子BEGIN dbms_output.put_line('最简单的PL/SQL');END;declare v_money number(4,1) := 2.3;begin dbms_output.put_line(v_money);end;--第二个小例子DECLARE v_ename VARCHAR2(20); --运行时在输入 v_ename2 v_ename%type; --引用另一个变量的类型 v_empno NUMBER(4) not null := 7999; --初始化 v_empno2 NUMBER(4); --运行时在输入 v_job emp.job%type; --变量与job列的数据类型和宽度一致 v_hiredate emp.hiredate%type default sysdate; --赋默认值 v_sal CONSTANT emp.sal%type := 3000; --常量 BEGIN --赋值方式 1： v_ename := '&amp;请输入员工姓名：'; --&amp;号表示一个替代变量，可在运行时输入值，字符串需用单引号括起来 v_empno2 := &amp;请输入员工编号; --赋值方式 2： select 列名列表 into 变量列表（对号入座） --但是要注意现在给变量赋值不能返回多行，要处理多行的查询结果需要用到游标 SELECT job INTO v_job FROM emp WHERE empno=v_empno2; --8001 dbms_output.put_line('员工编号:'||v_empno2||', 员工姓名：'||v_ename||', 职务：'||v_job||', 入职时间：'||v_hiredate);END;--更新方式(emp 为 new_scott 的同义词 synonym)declare v_empno emp.empno%TYPE; v_ename emp.ename%TYPE; v_sal emp.sal %TYPE;begin v_empno:=&amp;员工工号; select ename,sal into v_ename,v_sal from emp where emp.empno = v_empno; dbms_output.put_line(v_empno||' 的名字是：'||v_ename||' 薪水是：'||v_sal); if v_sal &lt; 3000 then update emp set sal = sal +500 where empno = v_empno; dbms_output.put_line(v_ename||'加薪完成！'); else dbms_output.put_line('薪水已经很高了！'); end if; end;--IF-ELSE案例--create or replace procedure emp_add_sal--is -- begin declare v_empno emp.empno% rec_emp emp%rowtype; begin v_empno := &amp;员工编号; --更新前 select * into rec_emp from emp where empno = v_empno; dbms_output.put_line('更新前：员工编号：'||rec_emp.empno||', 员工名字：'||rec_emp.ename||'， 员工工资：'||rec_emp.sal); if(rec_emp.sal&lt;3000) then update emp set sal = sal-500 where empno = v_empno; else update emp set sal = sal-200 where empno = v_empno; end if; -- commit; --更新后 select * into rec_emp from emp where empno = v_empno; dbms_output.put_line('更新后：员工编号：'||rec_emp.empno||', 员工名字：'||rec_emp.ename||'， 员工工资：'||rec_emp.sal); --处理没有找到数据的异常 exception when NO_DATA_FOUND THEN dbms_output.put_line('查无此人！'); when others then dbms_output.put_line('错误代码：'||SQLCODE ||',错误信息：'||SQLERRM); end;--end emp_add_sal;/--drop procedure emp_add_sal;--CASE_WHEN/* ---------------------------------------第五章 PL/SQL 作业-----------------------------------*/--A. 使用LOOP循环求1-100之间的素数/*50. 打印99乘法表 1*1=1 2*1=2 2*2=4 3*1=3 3*2=6 3*3=9*/--第一种方式declare v_score integer default 0;begin v_score:= &amp;成绩; case when v_score &gt;=80 then dbms_output.put_line('优秀'); when v_score &gt;=70and v_score&lt;80 then dbms_output.put_line('良好'); when v_score &gt;=60 and v_score &lt;70 then dbms_output.put_line('一般'); else dbms_output.put_line('不及格'); end case; end;--第二种方式declare v_grade char(2);begin case '&amp;grade' -- 此处一定注意：如果是字符型一定要加上 '' 否者报错，，，如果是数值型则不需要加 ’‘ when 'A' then dbms_output.put_line('优秀'); when 'B' then dbms_output.put_line('良好'); when 'C' then dbms_output.put_line('一般'); else dbms_output.put_line('不及格'); end case;end;--循环declare v_row int:= &amp;行数; v_counter1 int :=1; v_counter2 int :=1;begin loop v_counter1 := 1; loop dbms_output.put('*'); exit when v_counter1=v_counter2; v_counter1:=v_counter1+1; end loop; dbms_output.new_line; v_counter2:=v_counter2+1; exit when v_counter2 = v_row; end loop;end;--使用LOOP循环求1-100之间的素数declare v_prime int :=2; v_counter int default 1; counter int default 0; num int default 0;--统计个数begin loop counter:=0;--计数器（每次重新开始） v_counter:=2;--除数 从 2~v_prime 除（每次重新开始） loop if v_prime mod v_counter = 0 then counter:=counter+1; end if; exit when v_counter = v_prime or counter &gt; 2; --内循环结束条件 （2个条件满足一个即可跳出循环） v_counter:=v_counter+1;--除数自加 end loop; if counter = 1 then--输出语句 num:= num+1; if num&lt;&gt;1 then dbms_output.put(','); end if; dbms_output.put(v_prime); end if; exit when v_prime=100;--外循环结束条件 v_prime:= v_prime+1;--外循环自加 end loop; dbms_output.new_line;end;--九九乘法表declare counter1 int default 1; counter2 int default 1; begin counter1 :=&amp;乘法表范围; for i in 1..9 loop for j in 1..i loop dbms_output.put(i||'*'||j||'='||i*j); if(j&lt;&gt;i)then dbms_output.put(','); end if; end loop; dbms_output.new_line; end loop; end; --52.使用FOR循环求1-100之间的素数declare counter int :=0;begin for i in 2..100 loop counter:=0; for j in 2..i loop if mod(i,j)=0 then counter:=counter+1; end if; exit when counter &gt;1; end loop; if counter = 1 then dbms_output.put(i||','); end if; end loop; dbms_output.new_line;end;/*练习：根据部门名称，按以下格式打印"RESEARCH"部门所有人员姓名： 部门名称：RESEARCH 部门人员：SMITH,JONES,FORD*/declare counter int ; v_ename emp.ename%type;begin dbms_output.put_line('部门名称：'||'RESEARCH'); dbms_output.put('部门人员：'); select count(*) into counter from emp e,newdept n --统计有多少个符合条件的 where e.deptno = n.deptno and n.dname = 'RESEARCH'; for i in 1..counter loop --由于每次只能打印一个，所以用for循环 select ename into v_ename from ( select rownum r,ename --用伪列rownum 为每一个符合的条件做个编号，以便输出 from emp e join newdept n on e.deptno = n.deptno and n.dname = 'RESEARCH' )a where a.r = i; dbms_output.put(v_ename); if i&lt;&gt;counter then dbms_output.put(','); end if; end loop; dbms_output.new_line();end;--51. 根据工资查询员工姓名。如果此员工不存在（发出NO_DATA_FOUND异常），则打印相应的提示信息。declare v_sal emp.sal%type; v_ename emp.ename%type;begin v_sal := &amp;请输入工资; select ename into v_ename from emp where sal = v_sal; dbms_output.put_line('工资为：'||v_sal||'的员工姓名是：'||v_ename); exception when NO_DATA_FOUND then dbms_output.put_line('查无此人！');end;---自定义异常declare v_empno emp.empno%type:=&amp;加薪员工的工号; v_count int default 0; v_sal emp.sal%type; invlite_sal exception;--自定义异常 no_found exception; --自定义异常begin v_sal:=&amp;工资; if v_sal&lt;0 then raise invlite_sal; -- 手动抛出异常 end if; select count(*) into v_count from emp where empno = v_empno; if(v_count = 0) then raise no_found ; --手动抛出异常 end if; exception --捕获异常 when no_found then dbms_output.put_line('没有符合的信息！'); when invlite_sal then dbms_output.put_line('工资不可为负！'); end;--记录类型declare type rec_emp_type is record( empno emp.empno%type, ename emp.ename%type, sal emp.sal%type ); no_found exception; rec rec_emp_type ; v_count int:=0; v_empno emp.empno%type:=&amp;请输入员工工号;begin select count(*)into v_count from emp where empno = v_empno; if v_count = 0 then raise no_found; end if; select empno,ename,sal into rec from emp where empno = v_empno; dbms_output.put_line('员工工号：'||rec.empno ||'员工姓名：'||rec.ename ||'员工薪水：'||rec.sal); exception when no_found then -- raise_application_error(-20010,'查无此人'); dbms_output.put_line('查无此人');end; -------------------------------------------第六章 游标--------------------------------------------------- ----游标(loop访问) declare cursor cv_emp is --1.定义游标 cursor 游标名 is （select 语句） select e.* ,rownum from emp e; rec_emp cv_emp%rowtype; --定义一个游标类型的变量，保存每次结果 begin open cv_emp; --2.打开游标 open 游标名； loop fetch cv_emp into rec_emp; -- 3.从游标中获取数据 ： fetch 有标明 into 变量 dbms_output.put_line(rec_emp.empno||' '||rec_emp.rownum); exit when cv_emp%NOTFOUND; end loop; close cv_emp; --4.关闭游标 close 游标名 end; --while访问 declare cursor cv_emp is select e.*,rownum from emp e ;--order by empno rec_emp cv_emp%rowtype; begin open cv_emp; fetch cv_emp into rec_emp; --因为游标是从0开始，第零个没有数据，所以要跳过， while cv_emp%FOUND LOOP dbms_output.put_line(rec_emp.empno||' '||REC_EMP.ROWNUM); fetch cv_emp into rec_emp; END LOOP; close cv_emp; end; --for declare cursor cv_emp is select e.*,rownum from emp e ;--order by empno begin for rec_emp in cv_emp loop --for 不需要特意定义 游标变量，因为 ORACLE 自动分配计数器变量 dbms_output.put_line(rec_emp.empno||' '||rec_emp.rownum); end loop ; end; --for 升级版begin for rec_emp in (select e.*,rownum from emp e ) loop --直接用select 语句作为 匿名的 cursor dbms_output.put_line(rec_emp.empno||' '||rec_emp.rownum); end loop ;end; /* ---------------------------------------------第六章 游标管理 作业----------------------------------*//*（一）什么是游标：（二）隐式游标：在 PL/SQL 程序中执行DML SQL 语句时自动创建隐式游标。 并且只能访问最近执行的一条DML语句，查询只能返回一行。（三）显式游标用于处理返回多行的查询。 1）无参数的显式游标 2）带参数的显式游标 语法： cursor 游标名(参数名 类型) is select_statement;（四）隐式游标的特性： 1）在PL/SQL中使用DML语句时自动创建隐式游标 2）隐式游标自动声明、自动打开和自动关闭，其名为: SQL 3）通过检查隐式游标的属性可以获得最近一次执行的DML 语句的信息 4）游标的属性有： （1）%FOUND – SQL语句查询或影响了一行或多行时为 TRUE （2）%NOTFOUND – SQL语句没有影响任何行时为 TRUE （3）%ROWCOUNT – SQL语句影响的行数 （4）%ISOPEN - 检查游标是否打开，隐式游标始终为FALSE （五）使用游标更新行 1) 查询时使用 select .. from table where 条件 for update [of column [nowait]]子句锁定需要更新的行或列。 2) update employee set sal=sal-2 where current of 游标;*/--54. 显示EMP中的第四条记录。 如：游标%rowcount=4declare cursor cv_emp is select * from emp; rec_emp cv_emp%rowtype;beginopen cv_emp; loop fetch cv_emp into rec_emp; --先移动，再读取 if cv_emp%rowcount = 4 then dbms_output.put_line(rec_emp.empno||' '||rec_emp.ename); end if; exit when cv_emp%rowcount = 4; end loop; close cv_emp;end;/*55：针对所有部门，按以下格式打印各部门人员姓名： 部门名称：RESEARCH 部门人员：SMITH,JONES,FORD 部门名称：ACCOUNTING 部门人员：CLARK,KING,MILLER 两种实现提示： 1）循环每个部门，用其部门号作条件去查员工表 2）用显示cursor完成 3）要求用FOR，会用到嵌套循环。*/--方法一：不带参数游标declare begin for rec_emp in (select dname,deptno from newdept d) loop dbms_output.put_line('部门名称：'||rec_emp.dname); dbms_output.put('部门人员：'); for rec_tep in (select e.ename ename ,e.deptno deptno from emp e join newdept n on e.deptno = n.deptno ) loop if rec_tep.deptno = rec_emp.deptno then dbms_output.put(rec_tep.ename||','); end if; end loop; dbms_output.new_line; end loop;end;--方式二：带参数游标declare cursor cv_dept is select * from newdept ; cursor cv_employee (cp_deptno emp.deptno%type)--传递一个员工部门参数，根据参数锁定该部门信息 is select * from emp where deptno = cp_deptno;begin for cp_dept in cv_dept loop dbms_output.put_line('部门名称：'||cp_dept.dname); dbms_output.put('部门员工：'); for cp_emp in cv_employee(cp_dept.deptno) loop --内循环中的参数是外循环给的，通过每一个部门参数，打印结果 dbms_output.put(cp_emp.ename||','); end loop; dbms_output.new_line; dbms_output.new_line; --空一行 end loop;end; /*56. 对所有员工,如果该员工职位是MANAGER，并且在DALLAS工作那么就给他薪金加15％；如果该员工职位是CLERK，并且在NEW YORK工作那么就给他薪金扣除5％;其他情况不作处理*/--方式二： 游标declare cursor cv_emp(p_job emp.job%type,p_loc newdept.loc%type)is select e.sal,e.deptno,n.loc from emp e,newdept n where e.deptno = n.deptno and p_job = e.job and p_loc = n.loc for update; v_job emp.job%type; v_loc newdept.loc%type;begin v_job:='&amp;工作：'; v_loc:='&amp;地点：'; for rec_emp in cv_emp(v_job,v_loc) loop if v_job='MANAGER' and v_loc = 'DALLAS' then update emp set sal= sal*(1+0.15) where current of cv_emp; end if; if v_job='CLERK' and v_loc = 'NEW YORK' then update emp set sal= sal*(1-0.05) where current of cv_emp; end if; end loop;end;--方式一:declare cursor cv_emp is select empno ,e.job job, n.loc loc from emp e join newdept n on e.deptno = n.deptno for update;begin FOR rec_emp in cv_emp loop if rec_emp.job ='MANAGER' and rec_emp.loc ='DALLAS' then update emp set sal= sal*(1+0.15) where empno = rec_emp.empno; --where current of cv_emp; DBMS_OUTPUT.PUT_LINE('加薪10%完成！'); else if rec_emp.job ='CLERK' and rec_emp.loc ='NEW YORK' then update emp set sal= sal*(1-0.05) where empno = rec_emp.empno; -- where current of cv_emp; DBMS_OUTPUT.PUT_LINE('减薪5%完成！'); end if; end if; end loop;end;--验证过程select empno ,e.job job, n.loc loc ,e.sal from emp e join newdept n on e.deptno = n.deptno and e.job = 'MANAGER' and n.loc = 'DALLAS'; --1 7566 MANAGER DALLAS 4275.00 --1 7566 MANAGER DALLAS 5653.69select empno ,e.job job, n.loc loc,e.sal from emp e join newdept n on e.deptno = n.deptno and e.job = 'CLERK' and n.loc = 'NEW YORK';--1 7934 CLERK NEW YORK 1300.00--1 7934 CLERK NEW YORK 1433.25--57.(使用游标更新行) 编写一PL/SQL，对所有的"销售员"(SALESMAN)增加佣金500. -- 1) 查询时使用 select .. from table where 条件 for update [of column [nowait]]子句锁定需要更新的行或列。 -- 2) update employee set sal=sal-2 where current of 游标;declare cursor cv_emp(p_job emp.job%type) is select * from emp for update OF sal nowait; v_job emp.job%type;begin v_job:= '&amp;请输入工作'; for rec_emp in cv_emp(v_job) loop update emp set comm= comm+500 where current of cv_emp; --update employee set sal=sal-2 where current of 游标; end loop;end;--58. 编写一PL/SQL，以提升两个资格最老的"CLERK(职员)"为"HIGHTCLERK(高级职员)"。（工作时间越长，优先级越高）--alter table new_scott modify ( job varchar2(10));declare cursor cv_emp is select * from emp order by hiredate ;begin for rec_emp in cv_emp loop if cv_emp%rowcount &lt;=2 then update emp set job = 'HIGHTCLERK' where empno = rec_emp.empno; end if; end loop;end;--方式二：游标方式declare --游标选定job为CLERK 的员工，并按受雇时间 cursor cv_emp is select hiredate ,job from emp where job = 'CLERK' order by hiredate for update ;begin for rec_emp in cv_emp loop if cv_emp%rowcount &lt;3 then --限制只修改两个 update new_scott set job = 'HIGHTCLERK' where current of cv_emp; end if; end loop; end; select * from new_scott;/*59. 对直接上级是'BLAKE'的所有员工，按照参加工作的时间加薪： 81年6月以前的加薪10％ 81年6月以后的加薪5％*/declare cursor cv_emp is select * from emp where mgr = (select empno from emp where ename = 'BLAKE');begin for rec_emp in cv_emp loop if MONTHS_BETWEEN(rec_emp.hiredate,to_date('1981/6/1','yyyy/mm/dd'))&gt;0 then update emp set sal=sal*(1+0.05) where empno = rec_emp.empno; else update emp set sal=sal*(1+0.1) where empno = rec_emp.empno ; end if; end loop; end;--方式二：游标方法declare cursor cv_emp(p_ename emp.ename%type) is select * from emp where mgr = (select empno from emp where ename = p_ename) for update of sal; v_ename emp.ename%type;begin v_ename:= '&amp;上级姓名'; for rec_emp in cv_emp(v_ename) loop if MONTHS_BETWEEN(rec_emp.hiredate,to_date('1981/6/1','yyyy/mm/dd'))&gt;0 then update emp set sal=sal*(1+0.05) where current of cv_emp; else update emp set sal=sal*(1+0.1) where current of cv_emp ; end if; end loop;end;/*----------------------------------------------------第7章 过程和函数----------------------------------------------*//*60. 编写一个给指定雇员加薪10%的过程：Raise_Sal(p_ename)，这之后，检查如果已经雇佣该雇员超过60个月，则给他额外加薪3000.*/create or replace procedure Raise_Sal(p_ename emp.ename%type)is cursor cv_rise(p_ename emp.ename%type) is select * from emp where ename = p_ename for update of sal; cursor cv_emp is select * from emp where months_between(sysdate,hiredate)&gt;60 for update of sal;--后一部分begin for emp in cv_rise(p_ename) loop update emp set sal=sal*(1+0.1) where current of cv_rise ; end loop; for emp in cv_emp loop update emp set sal = sal+3000 WHERE current of cv_emp ; end loop; --commit; exception when others then rollback; dbms_output.put_line('操作有误，已经撤销！');end;--调用declare v_ename emp.ename%type;begin v_ename:='&amp;需要加薪的员工的名字：'; Raise_Sal(v_ename);end;--验证select * from emp;/*61. 编写一个过程打印出99的乘法表。*/create or replace procedure pro_9_9isbegin for i in 1..9 loop for j in 1..i loop dbms_output.put(i||'*'||j||'='||i*j||' '); end loop; dbms_output.new_line; end loop;end;--调用过程begin pro_9_9;end;/*62.编写一个过程完成两个数字的交换*/create or replace procedure date_change(no1 in out int,no2 in out integer )is v_temp int ;begin v_temp := no1; no1 := no2; no2 := v_temp;end;--调用declare v_on1 int :=&amp;请输入第一个数字; v_on2 int :=&amp;请输入第二个数字;begin date_change(v_on1,v_on2); dbms_output.put_line('交换后：第一个数字：'||v_on1||' 第二个参数：'||v_on2);end;/* --drop table log_msg cascade constraint;//删除表同时删除约束63. 编写三个过程完成 (1)开户功能。open_account(.....); (2)两个账户的转账功能。transaction(from帐户，to帐户,money) a)检查帐户是否存大？不存在的情况出异常。 b)转入转出帐户必须要在一个事务里进行。 (3)根据转出账号和交易时间段 可查询转出账号的所有交易记录。最后还需要返回该时间段转出的总金额。 a)向“交易日志表”插入数据。 b)交易号的生成规则：'T10000-'||trans_seq.nextval --&gt; T10000-1000 表结构如下： 1. 账户表：账号（6722 6738 xxxx yyyy）,户名，身份证号，余额，开户时间。 说明：账号后8位数随机生成。dbms_random.value函数可以得一个八位小数的随机小数。 select dbms_random.value from dual;select trunc(dbms_random.value*100000000,0) from dual; 2. 交易日志表：交易号(T10000-999)，转出账户，转入账户，交易金额，交易时间systimestamp。 说明：交易号使用序列生成。*/--1.custome_account表create table custome_account ( accountno varchar2(16) not null primary key , aname varchar2(6) not null , idno varchar2(18)unique, money number(20,3) check (money&gt;0), opentime date default systimestamp )--1.1建立账号表视图create or replace view acc asselect * from custome_account;--2.logtable 表create table log_msg ( tradeno varchar2(11)not null primary key, fromaccount varchar2(16) , toaccourt varchar2(16), money number(20,3), tradetime date default systimestamp, constraint FK_ACCOUT_LOG_FROMACCOUT foreign key(fromaccount) referenceS custome_account(accountno), constraint FK_ACCOUT_LOG_TOACCOUT foreign key(toaccourt) referenceS custome_account(accountno))--1.1建立交易表视图create or replace view tra asselect * from log_msg;--1.2 建立开户过程create or replace procedure open_account(p_aname acc.aname%type,aid acc.idno%type,money acc.money%type, p_accountno out acc.ACCOUNTNO%type )is v_rand number(20); v_num int default 0; v_account acc.ACCOUNTNO%type; id_has_exist exception; --该身份证已经开过户 name_has_exist exception; --该姓名已经注册begin select count(*) into v_num from acc where aid= idno; if v_num &gt; 0 then raise id_has_exist; end if; select count(*) into v_num from acc where ANAME= p_aname ; if v_num &gt; 0 then raise name_has_exist; end if; select trunc(dbms_random.value*100000000,0) into v_rand from dual;--产生一个8位的随机数 v_account:=CONCAT('67226738',to_char(v_rand)); --根据前缀产生一个账号 p_accountno:=v_account; --作为返回值返回 insert into acc values(v_account,p_aname,aid,money,sysdate); dbms_output.put_line(v_account||' '||p_aname||' '||aid||' '||money||' '||sysdate);--检验输出 commit; exception when id_has_exist then raise_application_error('-20012','该身份证已经开户,请换其他身份证继续！！'); when name_has_exist then raise_application_error('-20002','该客户已经存在，不能重名！！'); when others then rollback; raise_application_error('-20011','操作失败,已撤销！！');end open_account; --1.3 测试(------------------------------------------开户过程----------------------------------------) declare aname acc.aname%type; aid acc.idno%type; money acc.money%type; v_account acc.ACCOUNTNO%type;--记录返回账号 begin aname:='&amp;开户姓名'; aid:='&amp;身份证号'; money:=&amp;余额; open_account(aname,aid,money,v_account); dbms_output.put_line('恭喜您开户成功！您的账户为：'||v_account); end ; select * from acc;--2.1 转账功能工程transactioncreate or replace procedure pro_tract(p_fromaccount tra.FROMACCOUNT%type, p_toaccount tra.TOACCOURT%type,p_money tra.MONEY%type)is v_counter int default 0; v_money tra.MONEY%type; no_found_from exception; no_found_to exception; no_enough exception; data_error exception; no_equals exception;begin if p_money&lt;0 then raise data_error; end if; select count(*) into v_counter from acc where ACCOUNTNO = p_fromaccount; if v_counter = 0 then raise no_found_from; end if ; select money into v_money from acc where ACCOUNTNO = p_fromaccount; if (v_money- p_money)&lt;0 then raise no_enough; end if ; select count(*) into v_counter from acc where ACCOUNTNO = p_toaccount; if v_counter = 0 then raise no_found_to; end if ; if p_fromaccount = p_toaccount then raise no_equals; end if; update acc set money = money-p_money where acc.ACCOUNTNO = p_fromaccount; update acc set money = money+p_money where acc.ACCOUNTNO = p_toaccount; insert into tra(tradeno,fromaccount,toaccourt,money) values ( to_char('T10000-'||to_char(sq_tra_log.nextval)) ,p_fromaccount, p_toaccount,p_money);----------------------------------------- dbms_output.put_line('转账成功！'); commit; exception when no_found_from then raise_application_error('-20013','转出账户不存在！'); when no_found_to then raise_application_error('-20014','转入账户不存在！'); when no_enough then raise_application_error('-20015','转出账户余额不足！'); when data_error then raise_application_error('-20016','转账数额不能为负值！'); when no_equals then raise_application_error('-20030','转出账户与转入账户相同！'); when others then raise_application_error('-20017','操作失败,动作已撤销！'); rollback;end pro_tract; select * from acc; select * from tra; --2.2 测试(-------------------------------------------------转账过程测试----------------------------------)declare v_fromaccount tra.FROMACCOUNT%type; v_toaccount tra.TOACCOURT%type; v_money tra.MONEY%type;begin v_fromaccount :='&amp;转账账号'; v_toaccount :='&amp;收账账号'; v_money:=&amp;转账金额; pro_tract(v_fromaccount,v_toaccount,v_money); commit; /* exception -- 加了这个异常后，raise_application_error 不在显示 when others then dbms_output.put_line('转账失败！');*/end;--2.3创建序列 create sequence sq_tra_log start with 999; --3.1/* (3)根据转出账号和交易时间段 可查询转出账号的所有交易记录。最后还需要返回该时间段转出的总金额。 a)向“交易日志表”插入数据。 b)交易号的生成规则：'T10000-'||trans_seq.nextval --&gt; T10000-1000 */create or replace procedure pro_search_trace(p_fromaccount tra.FROMACCOUNT%type, begintime date,endtime date, totalmoney out tra.MONEY%type)is cursor cv_accot is select * from tra where FROMACCOUNT = p_fromaccount and TRADETIME between begintime and endtime ; v_counter int default 0; time_error exception; no_found_from exception;begin if months_between(begintime ,endtime)&gt;0 then raise time_error; end if; select count(*) into v_counter from tra where FROMACCOUNT = p_fromaccount; if v_counter = 0 then raise no_found_from; end if ; totalmoney:=0; dbms_output.put_line(p_fromaccount||' 在 '||to_char(begintime, 'yyyy"年"mm"月"dd"日"')||' ~ '||to_char(endtime,'yyyy"年"mm"月"dd"日"')||' 时间段内的交易清单：'); dbms_output.new_line; for tra_accot in cv_accot loop totalmoney:=totalmoney+tra_accot.MONEY; dbms_output.put_line(tra_accot.tradeno||' '||tra_accot.fromaccount|| ' '||tra_accot.toaccourt||' '||to_char(tra_accot.money,'L999,999,999.00')||' '||to_char(tra_accot.tradetime,'yyyy"年"mm"月"dd"日"')); end loop; dbms_output.new_line; exception when time_error then raise_application_error('-20040','起始时间不能晚于结束时间！'); when no_found_from then raise_application_error('-20018','没有发现该账户的交易记录！'); when others then raise_application_error('-20019','查询异常！');end pro_search_trace ;--3.2 测试(----------------------------------------------------交易记录查询测试------------------------------------------------------)declare p_fromaccount tra.FROMACCOUNT%type; begintime date; endtime date; v_totalmony tra.MONEY%type ;begin p_fromaccount:='&amp;请输入查询账户'; begintime:=to_date('&amp;请输入开始时间','yyyy/mm/dd'); endtime:=to_date('&amp;请输入结束时间','yyyy/mm/dd'); pro_search_trace(p_fromaccount,begintime ,endtime,v_totalmony ); dbms_output.put_line('合计：'); dbms_output.put_line(p_fromaccount||' 在 '||to_char(begintime, 'yyyy"年"mm"月"dd"日"')||' ~ '||to_char(endtime,'yyyy"年"mm"月"dd"日"')||' 时间段内的交易额为: '||to_char(v_totalmony,'L999,999.00'));end ;select * from tra;select * from acc;/*-----------------------------------------------------------------函数 -----------------------------------------------*/--65. 基于账户表，编写一个函数通过账号获得账户余额；如果输入的账号不存在则显示相应的异常信息。create or replace function get_balance (accno acc.ACCOUNTNO%type) return number is v_balance acc.MONEY%type; begin select money into v_balance from acc where ACCOUNTNO = accno; return v_balance ; end; --- select get_balance('6722673861353700') from dual;--66. 检测一个值是否落在了正常的员工工资范围内create or replace function check_sal (sal salgrade.losal%type) return varchar2 is v_losal salgrade.losal%type; v_hisal salgrade.losal%type; begin select min(losal)into v_losal from salgrade; select max(hisal) into v_hisal from salgrade; if sal&gt;v_losal and sal &lt; v_hisal then return '在正常工资范围！'; else return '不在正常工资范围！'; end if ; end; select check_sal(690) from dual; select * from salgrade;--67. 编写一个函数获得指定部门的平均工资。create or replace function get_avg_sal(p_dname newdept.dname%type)return numberis v_avg new_scott.sal%type; v_counter int default 0; no_dept exception;begin select count(dname) into v_counter from newdept where p_dname=dname; if(v_counter=0) then raise no_dept; end if; select avg(sal) into v_avg from new_scott where deptno = (select deptno from newdept where dname = p_dname); return v_avg; exception when no_dept then raise_application_error('-20048','不存在该部门');end;--SQL/PL语句declare v_dname newdept.dname%type; v_avg_sal new_scott.sal%type;begin v_dname:='&amp;请输入部门名称'; v_avg_sal:= get_avg_sal(v_dname) ; dbms_output.put_line(v_avg_sal);end;select * from newdept;--68. 综合应用，利用第67题的函数，编写一个过程将所有部门的平均显示出来。create or replace procedure search_avgis cursor cv_dept is select dname from newdept; v_avg new_scott.sal%type default 0;begin for rec_dname in cv_dept loop v_avg := get_avg_sal(rec_dname.dname); dbms_output.put_line(rec_dname.dname||'部门的平均工资是：'||v_avg); end loop;end;--beginsearch_avg;end;-------------------------------------------------触发器----------------------------------trigger/*--------------------------------------------------(了解) 触发器 -------------------------------------------------------- 1. 什么是触发器：触发器在数据库里以独立的对象存储，它与存储过程和函数不同的是，存储过程与函数需要用户显示调用才执行， 而触发器是由一个事件来启动运行。即触发器是当某个事件发生时自动地隐式运行。并且，触发器不能接收参数。 所以运行触发器就叫触发或点火。 2. ORACLE事件指的是对数据库的表进行的INSERT、UPDATE及DELETE操作或对视图进行类似的操作。 3. 触发器不接受参数。 触发器组成: 1)触发事件：引起触发器被触发的事件。 例如：DML语句(INSERT, UPDATE, DELETE语句对表或视图执行数据处理操作)、 DDL语句（如CREATE、ALTER、DROP语句在数据库中创建、修改、删除模式对象）、数据库系统事件（如系统启动或退出、异常错误）、 用户事件（如登录或退出数据库）。 2)触发时间：即该TRIGGER 是在触发事件发生之前（BEFORE）还是之后(AFTER)触发，也就是触发事件和该TRIGGER 的操作顺序。 3)触发操作：即该TRIGGER 被触发之后的目的和意图，正是触发器本身要做的事情。 例如：PL/SQL 块。 4)触发对象：包括表、视图、模式、数据库。只有在这些对象上发生了符合触发条件的触发事件，才会执行触发操作。 5)触发条件：由WHEN子句指定一个逻辑表达式。只有当该表达式的值为TRUE时，遇到触发事件才会自动执行触发器， 使其执行触发操作。 6)触发频率：说明触发器内定义的动作被执行的次数。即语句级(STATEMENT)触发器和行级(ROW)触发器。 a)语句级(STATEMENT)触发器：是指当某触发事件发生时，该触发器只执行一次； b)行级(ROW)触发器：是指当某触发事件发生时，对受到该操作影响的每一行数据，触发器都单独执行一次。 REFERENCING 参照名称：OLD,NEW都是代表当前操作的记录行 1) 默认的相关名称分别为OLD和NEW，参照当前DML操作的新、旧列值 2) 触发器的PL/SQL块中应用相关名称时，必须在它们之前加冒号(:)，但在WHEN子句(触发条件)中则不能加冒号。 语法：create or replace trigger 触发器名 触发时间(BEFORE|AFTER) 触发事件(INSERT OR UPDATE OR DELETE) [of 列名] on 触发对象(表等) 触发频率 when (触发条件) declare --声明变量等 begin --执行部分 end 触发器名;*/--当更新或插入员工的奖金时，其奖金comm大于1000时，sal工资自动多加10元create or replace trigger auto_raise_sal_trg before insert or update of comm on employee for each row --表示行级触发器 when (NEW.comm&gt;=1000)declare begin --触发器里预定义了三个操作条件 -- inserting,updating,deleting触发动作条件，其值为boolean，只能在触发器主体中使用 if inserting then --触发器的PL/SQL块中应用相关名称时，必须在它们之前加冒号(:)，但在WHEN子句(触发条件)中则不能加冒号。 :NEW.sal := :NEW.sal + 10; end if; if updating then :NEW.sal := :OLD.sal + 10; end if;end auto_raise_sal_trg;--建表 test_trgdrop table test_trg;create table test_trg( tid varchar2(4))create sequence test_trg_seqstart with 1;--使用触发器为表在插入数据时生成一个id值：A序号(序号用序列生成)create table test_id( tid varchar2(4))create sequence test_id_sqstart with 1;create or replace trigger auto_id before insert on test_id for each row when (new.tid is null) declare v_id test_id.tid%type;begin select 'A'||test_id_sq.nextval into v_id from dual; :new.tid := v_id;end;--insert into test_id values('159'); select * from test_id;--删除触发器drop trigger auto_raise_sal_trg;--禁用或启用触发器alter trigger auto_raise_sal_trg disable; --enableinsert into employee(empno,ename,job,sal,comm,deptno) values(employee_seq.nextval,'小美','CLERK',4000.0,1000,10); update employee set comm=1500 where ENAME='小美';------------------------------------------------select * from employee WHERE ENAME='小美' order by empno DESC; select * from department;select * from salgrade;]]></content>
  </entry>
  <entry>
    <title><![CDATA[各大互联网公司架构汇总]]></title>
    <url>%2F2018%2F03%2F19%2F%E5%90%84%E5%A4%A7%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E6%9E%B6%E6%9E%84%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[任何一个公司在逐渐成长时候，难免会遇到技术上的难点痛点。当我们遇到这种问题时候是否想过有没有公司在你之前遇到过而且解决过类似的问题。本文收集一些不错的大公司演进之路的优秀文章。希望给正在苦苦思索的人一些帮助。 理论及技术大型网站架构演化历程大型网站架构技术一览 大型网站支付宝和蚂蚁花呗的技术架构及实践支付宝的高可用与容灾架构演进聚划算架构演进和系统优化 （视频+PPT）淘宝交易系统演进之路 （专访）淘宝数据魔方技术架构解析淘宝技术发展历程和架构经验分享（视频+PPT）阿里游戏高可用架构设计实践高德——快速转型时期的稳定性架构实践（视频+PPT）秒杀系统架构分析与实战腾讯社区搜索架构演进（视频+PPT）京东峰值系统设计京东咚咚架构演进大促系统全流量压测及稳定性保证——京东交易架构分享（含PPT）京东618实践：一元抢宝系统的数据库架构优化京东上千页面搭建基石——CMS前后端分离演进史新浪微博平台架构微博图床架构揭秘微博推荐架构的演进微博众筹的架构设计当当网系统分级与海量信息动态发布实践当当网架构演进及规划实现（视频+PPT）LinkedIn架构这十年4亿用户的LinkedIn数据产品设计原则和架构实现Facebook’s software architecture（英文）从0到100——知乎架构变迁史豆瓣的基础架构搜狗搜索广告检索系统-弹性架构演进之路（视频+PPT）小米网抢购系统开发实践小米抢购限流峰值系统「大秒」架构解密海尔电商峰值系统架构设计最佳实践唯品会峰值系统架构演变1号店电商峰值与流式计算蘑菇街如何在双11中创造99.99%的可用性蘑菇街电商交易平台服务架构及改造优化历程(含PPT)麦包包峰值架构实践苏宁易购：商品详情系统架构设计苏宁易购亿万级商品评价系统的架构演进之路和实现细节携程的技术演进之路篱笆网技术架构性能演进（视频+PPT）从技术细节看美团的架构美团云的网络架构演进之路百度开放云大数据技术演进历程（视频+PPT）途牛供应链系统的架构演进（视频+PPT）途牛订单的服务化演进Airbnb架构要点分享12306核心模型设计思路和架构设计ACFUN 的视频架构演化实践虎嗅：四年覆盖9成互联网企业中高层的网站架构演变涂鸦科技：支撑从零暴增数十亿数据的背后，竟无专职运维！宜人贷系统架构——高并发下的进化之路链家网技术架构的演进之路 ##移动app阿里无线技术架构演进支付宝钱包客户端技术架构手机淘宝构架演化实践手淘技术架构演进细节手机淘宝移动端接入网关基础架构演进之路微信后台系统的演进之路微信红包的架构设计简介微信Android客户端架构演进之路微信热补丁 Tinker 的实践演进之路Android QQ音乐架构演进（视频+PPT）快的打车架构实践Uber 四年时间增长近 40 倍，背后架构揭秘Uber容错设计与多机房容灾方案大众点评移动应用的架构演进（视频+PPT）饿了么移动APP的架构演进滴滴出行iOS客户端架构演进之路今日头条架构演进之路——高压下的架构演进专题（含PPT）今日头条 User Profile 系统架构实践（视频+PPT）余额宝技术架构及演进微博付费打赏架构：一个社交场景下准金融项目开发和实践千万级用户App小咖秀：服务端架构设计分享「脉脉」基础架构迁移实战：拯救大兵瑞恩 其他魅族实时消息推送架构魅族云端同步的架构实践和协议细节App架构经验总结]]></content>
  </entry>
  <entry>
    <title><![CDATA[58到家数据库30条军规解读]]></title>
    <url>%2F2018%2F03%2F19%2F58%E5%88%B0%E5%AE%B6%E6%95%B0%E6%8D%AE%E5%BA%9330%E6%9D%A1%E5%86%9B%E8%A7%84%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[军规适用场景：并发量大、数据量大的互联网业务 一、基础规范（1）必须使用InnoDB存储引擎 解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高 （2）必须使用UTF8字符集 解读：万国码，无需转码，无乱码风险，节省空间 （3）数据表、数据字段必须加入中文注释 解读：N年后谁tm知道这个r1,r2,r3字段是干嘛的 （4）禁止使用存储过程、视图、触发器、Event 解读：高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务层”，并发量大的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”。数据库擅长存储与索引，CPU计算还是上移吧 （5）禁止存储大文件或者大照片 解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URI多好 二、命名规范（6）只允许使用内网域名，而不是ip连接数据库（7）线上环境、开发环境、测试环境数据库内网域名遵循命名规范 业务名称：xxx线上环境：dj.xxx.db开发环境：dj.xxx.rdb测试环境：dj.xxx.tdb从库在名称后加-s标识，备库在名称后加-ss标识线上从库：dj.xxx-s.db线上备库：dj.xxx-sss.db （8）库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止拼音英文混用（9）表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx三、表设计规范（10）单实例表数目必须小于500（11）单表列数目必须小于30（12）表必须有主键，例如自增主键 解读：a）主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和内存的使用b）主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率c） 无主键的表删除，在row模式的主从架构，会导致备库夯住 （13）禁止使用外键，如果有外键完整性约束，需要应用程序控制 解读：外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql 的性能，甚至会造成死锁。高并发情况下容易造成数据库性能，大数据高并发业务场景数据库使用以性能优先 四、字段设计规范（14）必须把字段定义为NOT NULL并且提供默认值 解读：a）null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化b）null 这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多c）null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标识d）对null 的处理时候，只能采用is null或is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、not in这些操作符号。如：where name!=’shenjian’，如果存在name为null值的记录，查询结果就不会包含name为null值的记录 （15）禁止使用TEXT、BLOB类型 解读：会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能 （16）禁止使用小数存储货币 解读：使用整数吧，小数容易导致钱对不上 （17）必须使用varchar(20)存储手机号 解读：a）涉及到区号或者国家代号，可能出现+-()b）手机号会去做数学运算么？c）varchar可以支持模糊查询，例如：like“138%” （18）禁止使用ENUM，可使用TINYINT代替 解读：a）增加新的ENUM值要做DDL操作b）ENUM的内部实际存储就是整数，你以为自己定义的是字符串？ 五、索引设计规范（19）单表索引建议控制在5个以内（20）单索引字段数不允许超过5个 解读：字段超过5个时，实际已经起不到有效过滤数据的作用了 （21）禁止在更新十分频繁、区分度不高的属性上建立索引 解读：a）更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能b）“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似 （22）建立组合索引，必须把区分度高的字段放在前面 解读：能够更加有效的过滤数据 六、SQL使用规范（23）禁止使用SELECT *，只获取必要的字段，需要显示说明列属性 解读：a）读取不需要的列会增加CPU、IO、NET消耗b）不能有效的利用覆盖索引c）使用SELECT *容易在增加或者删除字段后出现程序BUG （24）禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性 解读：容易在增加或者删除字段后出现程序BUG （25）禁止使用属性隐式转换 解读：SELECT uid FROM t_user WHERE phone=13812345678 会导致全表扫描，而不能命中phone索引，猜猜为什么？（这个线上问题不止出现过一次） （26）禁止在WHERE条件的属性上使用函数或者表达式 解读：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全表扫描正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’) （27）禁止负向查询，以及%开头的模糊查询 解读：a）负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描b）%开头的模糊查询，会导致全表扫描 （28）禁止大表使用JOIN查询，禁止大表使用子查询 解读：会产生临时表，消耗较多内存与CPU，极大影响数据库性能 （29）禁止使用OR条件，必须改为IN查询 解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费更多的CPU帮助实施查询优化呢？ （30）应用程序必须捕获SQL异常，并有相应处理【文章摘自】：http://chuansong.me/n/1574852446614]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud学习资料大全]]></title>
    <url>%2F2018%2F03%2F19%2FSpringCloud%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[此篇文章主要整理一些优秀的博客及别人已经整理好的脚手架项目，帮助想用sc（spring cloud简称sc，后文同）而又无处下手的小白快速使用这个高（diao）大（zha）上（tian）的微服务框架。當然如果你對spring boot沒有瞭解的話，建議你先簡單學習一下然後再著手SC。 技术落地方案http://www.jianshu.com/p/1c0ee18140c2 SC优秀博客 许进 跟我学Spring Cloud 方志朋 Spring Cloud 专栏 程序猿DD liaokailin的专栏 周立 Spring Cloud SpringCloud官方网站 [英文]（http://projects.spring.io/spring-cloud/）[中文]（https://springcloud.cc/） 推荐github和码云上的sc项目脚手架项目 SpringCloud-Learning Spring Cloud微服务实战视频教程配套代码 基于 Spring Cloud 的微服务架构 文档类 使用Spring Cloud与Docker实战微服务]]></content>
  </entry>
  <entry>
    <title><![CDATA[项目中常用的19条MySQL优化]]></title>
    <url>%2F2018%2F03%2F19%2F%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%8419%E6%9D%A1MySQL%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一、EXPLAIN做MySQL优化，我们要善用 EXPLAIN 查看SQL执行计划。 下面来个简单的示例，标注(1,2,3,4,5)我们要重点关注的数据 type列，连接类型。一个好的sql语句至少要达到range级别。杜绝出现all级别 key列，使用到的索引名。如果没有选择索引，值是NULL。可以采取强制索引方式 key_len列，索引长度 rows列，扫描行数。该值是个预估值 extra列，详细说明。注意常见的不太友好的值有：Using filesort, Using temporary 二、SQL语句中IN包含的值不应过多MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。再例如：select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了；再或者使用连接来替换。 三、SELECT语句务必指明字段名称SELECT *增加很多不必要的消耗（cpu、io、内存、网络带宽）；增加了使用覆盖索引的可能性；当表结构发生改变时，前断也需要更新。所以要求直接在select后面接上字段名。 四、当只需要一条数据的时候，使用limit 1这是为了使EXPLAIN中type列达到const类型 五、如果排序字段没有用到索引，就尽量少排序六、如果限制条件中其他字段没有索引，尽量少用oror两边的字段中，如果有一个不是索引字段，而其他条件也不是索引字段，会造成该查询不走索引的情况。很多时候使用 union all 或者是union(必要的时候)的方式来代替“or”会得到更好的效果 七、尽量用union all代替unionunion和union all的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。当然，union all的前提条件是两个结果集没有重复数据。 八、不使用ORDER BY RAND()1select id from `dynamic` order by rand() limit 1000; 上面的sql语句，可优化为 1select id from `dynamic` t1 join (select rand() * (select max(id) from `dynamic`) as nid) t2 on t1.id &gt; t2.nid limit 1000; 九、区分in和exists， not in和not exists1select * from 表A where id in (select id from 表B) 上面sql语句相当于 1select * from 表A where exists(select * from 表B where 表B.id=表A.id) 区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。所以IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。关于not in和not exists，推荐使用not exists，不仅仅是效率问题，not in可能存在逻辑问题。如何高效的写出一个替代not exists的sql语句？ 原sql语句 1select colname … from A表 where a.id not in (select b.id from B表) 高效的sql语句 1select colname … from A表 Left join B表 on where a.id = b.id where b.id is null 取出的结果集如下图表示，A表不在B表中的数据 十、使用合理的分页方式以提高分页的效率1select id,name from product limit 866613, 20 使用上述sql语句做分页的时候，可能有人会发现，随着表数据量的增加，直接使用limit分页查询会越来越慢。 优化的方法如下：可以取前一页的最大行数的id，然后根据这个最大的id来限制下一页的起点。比如此列中，上一页最大的id是866612。sql可以采用如下的写法： 1select id,name from product where id&gt; 866612 limit 20 十一、分段查询在一些用户选择页面中，可能一些用户选择的时间范围过大，造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段进行查询，循环遍历，将结果合并处理进行展示。 如下图这个sql语句，扫描的行数成百万级以上的时候就可以使用分段查询 十二、避免在 where 子句中对字段进行 null 值判断对于null的判断会导致引擎放弃使用索引而进行全表扫描。 十三、不建议使用%前缀模糊查询例如LIKE “%name”或者LIKE “%name%”，这种查询会导致索引失效而进行全表扫描。但是可以使用LIKE “name%”。 那如何查询%name%？ 如下图所示，虽然给secret字段添加了索引，但在explain结果果并没有使用 那么如何解决这个问题呢，答案：使用全文索引 在我们查询中经常会用到select id,fnum,fdst from dynamic_201606 where user_name like ‘%zhangsan%’; 。这样的语句，普通索引是无法满足查询需求的。庆幸的是在MySQL中，有全文索引来帮助我们。 创建全文索引的sql语法是： 1ALTER TABLE `dynamic_201606` ADD FULLTEXT INDEX `idx_user_name` (`user_name`); 使用全文索引的sql语句是： 1select id,fnum,fdst from dynamic_201606 where match(user_name) against(&apos;zhangsan&apos; in boolean mode); 注意：在需要创建全文索引之前，请联系DBA确定能否创建。同时需要注意的是查询语句的写法与普通索引的区别 十四、避免在where子句中对字段进行表达式操作比如 1select user_id,user_project from user_base where age*2=36; 中对字段就行了算术运算，这会造成引擎放弃使用索引，建议改成 1select user_id,user_project from user_base where age=36/2; 十五、避免隐式类型转换where 子句中出现 column 字段的类型和传入的参数类型不一致的时候发生的类型转换，建议先确定where中的参数类型 十六、对于联合索引来说，要遵守最左前缀法则举列来说索引含有字段id,name,school，可以直接用id字段，也可以id,name这样的顺序，但是name;school都无法使用这个索引。所以在创建联合索引的时候一定要注意索引字段顺序，常用的查询字段放在最前面 十七、必要时可以使用force index来强制查询走某个索引1有的时候MySQL优化器采取它认为合适的索引来检索sql语句，但是可能它所采用的索引并不是我们想要的。这时就可以采用force index来强制优化器使用我们制定的索引。 十八、注意范围查询语句对于联合索引来说，如果存在范围查询，比如between,&gt;,&lt;等条件时，会造成后面的索引字段失效。 十九、关于JOIN优化 LEFT JOIN A表为驱动表 INNER JOIN MySQL会自动找出那个数据少的表作用驱动表 RIGHT JOIN B表为驱动表 注意：MySQL中没有full join，可以用以下方式来解决 1234select * from A left join B on B.name = A.name where B.name is null union allselect * from B; 尽量使用inner join，避免left join 参与联合查询的表至少为2张表，一般都存在大小之分。如果连接方式是inner join，在没有其他过滤条件的情况下MySQL会自动选择小表作为驱动表，但是left join在驱动表的选择上遵循的是左边驱动右边的原则，即left join左边的表名为驱动表。 合理利用索引 被驱动表的索引字段作为on的限制字段。 利用小表去驱动大表 从原理图能够直观的看出如果能够减少驱动表的话，减少嵌套循环中的循环次数，以减少 IO总量及CPU运算的次数。 巧用STRAIGHT_JOIN inner join是由mysql选择驱动表，但是有些特殊情况需要选择另个表作为驱动表，比如有group by、order by等「Using filesort」、「Using temporary」时。STRAIGHT_JOIN来强制连接顺序，在STRAIGHT_JOIN左边的表名就是驱动表，右边则是被驱动表。在使用STRAIGHT_JOIN有个前提条件是该查询是内连接，也就是inner join。其他链接不推荐使用STRAIGHT_JOIN，否则可能造成查询结果不准确。 这个方式有时可能减少3倍的时间。 这里只列举了上述优化方案，当然还有其他的优化方式，大家可以去摸索尝试，感谢关注。。 文章摘自：https://juejin.im/entry/5a1bbb386fb9a044fc4475aa?utm_source=gold_browser_extension]]></content>
  </entry>
  <entry>
    <title><![CDATA[Joda-Time使用手册]]></title>
    <url>%2F2018%2F03%2F19%2FJoda-Time%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[简介Joda-Time 令时间和日期值变得易于管理、操作和理解。事实上，易于使用是 Joda 的主要设计目标。其他目标包括可扩展性、完整的特性集以及对多种日历系统的支持。并且 Joda 与 JDK 是百分之百可互操作的，因此您无需替换所有 Java 代码，只需要替换执行日期/时间计算的那部分代码。本文主要就JDK date calendar 与 jodatime 对比。 一 、Joda-Time使用说明创建DateTime对象1234567891011121314//方法一 DateTime dateTime = new DateTime();//方法二（推荐使用此方法）DateTime dateTime = SystemFactory.getClock().getDateTime();//方法三DateTime dateTime = new DateTime( 2000, //year 1, // month 1, // day 0, // hour (midnight is zero) 0, // minute 0, // second 0 // milliseconds); 创建LocalDate，LocalTime对象LocalDate：该类封装了一个年/月/日的组合。当地理位置（即时区）变得不重要时，使用它存储日期将非常方便。例如，某个特定对象的出生日期 可能为 1999 年 4 月 16 日，但是从技术角度来看，在保存所有业务值的同时不会了解有关此日期的任何其他信息（比如这是一周中的星期几，或者这个人出生地所在的时区）。在这种情况下，应当使用 LocalDate。 12345//方法一LocalDate localDate = SystemFactory.getClock().getLocalDate();//方法二LocalDate localDate = new LocalDate(2009, 9, 6);// September 6, 2009 LocalTime：这个类封装一天中的某个时间，当地理位置不重要的情况下，可以使用这个类来只存储一天当中的某个时间。例如，晚上 11:52 可能是一天当中的一个重要时刻（比如，一个 cron 任务将启动，它将备份文件系统的某个部分），但是这个时间并没有特定于某一天，因此我不需要了解有关这一时刻的其他信息。 12345//方法一LocalTime localTime = SystemFactory.getClock().getLocalTime();//方法二LocalTime localTime = new LocalTime(13, 30, 26, 0);// 1:30:26PM 二、Joda处理时间日期计算例1：计算上一个月的最后一天?12LocalDate now = SystemFactory.getClock().getLocalDate();LocalDate lastDayOfPreviousMonth = now.minusMonths(1).dayOfMonth().withMaximumValue(); yearOfCentury dayOfYear monthOfYear dayOfMonth dayOfWeek例2：获得任何一年中的第 11 月的第一个星期二的日期，而这天必须是在这个月的第一个星期一之后？123456789LocalDate now = SystemFactory.getClock().getLocalDate();LocalDate electionDate = now.monthOfYear() .setCopy(11) // November .dayOfMonth() // Access Day Of Month Property .withMinimumValue() // Get its minimum value .plusDays(6) // Add 6 days .dayOfWeek() // Access Day Of Week Property .setCopy("Monday") // Set to Monday (it will round down) .plusDays(1); // Gives us Tuesday 例2注释帮助您了解代码如何获得结果。.setCopy(“Monday”) 是整个计算的关键。不管中间 LocalDate 值是多少，将其 dayOfWeek 属性设置为 Monday 总是能够四舍五入，这样的话，在每月的开始再加上 6 天就能够让您得到第一个星期一。再加上一天就得到第一个星期二。Joda 使得执行此类计算变得非常容易。 例3 ：计算从现在开始经过两个星期之后的日期12DateTime now = SystemFactory.getClock().getDateTime();DateTime then = now.plusWeeks(2); 例4：计算从明天起 90 天以后的日期123DateTime now = SystemFactory.getClock().getDateTime();DateTime tomorrow = now.plusDays(1);DateTime then = tomorrow.plusDays(90); 例5： 计算从现在起 156 秒之后的时间12DateTime now = SystemFactory.getClock().getDateTime();DateTime then = now.plusSeconds(156); 例6：计算五年后的第二个月的最后一天123456DateTime now = SystemFactory.getClock().getDateTime();DateTime then = now.minusYears(5) // five years ago .monthOfYear() // get monthOfYear property .setCopy(2) // set it to February .dayOfMonth() // get dayOfMonth property .withMaximumValue();// the last day of the month 三 、Joda 和 JDK 互操作性从 Joda DateTime 类创建 JDK 类12345DateTime dateTime = SystemFactory.getClock().getDateTime();Calendar calendar = dateTime.toCalendar(Locale.getDefault());Date date = dateTime.toDate();DateMidnight dateMidnight = SystemFactory.getClock().getDateMidnight();date = dateMidnight.toDate(); 从 Joda LocalDate 类创建 JDK 类12LocalDate localDate = SystemFactory.getClock().getLocalDate();Date date = localDate.toDateMidnight().toDate(); JDK 对象转换为Joda对象12java.util.Date jdkDate = obtainDateSomehow();dateTime = new DateTime(jdkDate); 将不同对象传递给 DateTime 的构造函数1234567891011// Use a Calendarjava.util.Calendar calendar = obtainCalendarSomehow();dateTime = new DateTime(calendar);// Use another Joda DateTimeDateTime anotherDateTime = obtainDateTimeSomehow();dateTime = new DateTime(anotherDateTime);// Use a String (must be formatted properly)String timeString = "2006-01-26T13:30:00-06:00";dateTime = new DateTime(timeString);timeString = "2006-01-26";dateTime = new DateTime(timeString); 以 Joda 方式格式化时间使用了 ISODateTimeFormat 的静态方法12345DateTime dateTime = SystemFactory.getClock().getDateTime();dateTime.toString(ISODateTimeFormat.basicDateTime());dateTime.toString(ISODateTimeFormat.basicDateTimeNoMillis());dateTime.toString(ISODateTimeFormat.basicOrdinalDateTime());dateTime.toString(ISODateTimeFormat.basicWeekDateTime()); 传递 SimpleDateFormat 字符串123456789101112DateTime dateTime = SystemFactory.getClock().getDateTime();dateTime.toString("MM/dd/yyyy hh:mm:ss.SSSa");dateTime.toString("dd-MM-yyyy HH:mm:ss");dateTime.toString("EEEE dd MMMM, yyyy HH:mm:ssa");dateTime.toString("MM/dd/yyyy HH:mm ZZZZ");dateTime.toString("MM/dd/yyyy HH:mm Z"); 09/06/2009 02:30:00.000PM06-Sep-2009 14:30:00Sunday 06 September, 2009 14:30:00PM09/06/2009 14:30 America/Chicago09/06/2009 14:30 -0500 四、对比例子1、初始化某个瞬间的对象（除 “现在” 以外）并加上特定天数 JDK 12345Calendar calendar = Calendar.getInstance();calendar.set(2000, Calendar.JANUARY, 1, 0, 0, 0);SimpleDateFormat sdf = new SimpleDateFormat("E MM/dd/yyyy HH:mm:ss.SSS");calendar.add(Calendar.DAY_OF_MONTH, 90);System.out.println(sdf.format(calendar.getTime())); *Joda12DateTime dateTime = new DateTime(2000, 1, 1, 0, 0, 0, 0);System.out.println(dateTime.plusDays(90).toString("E MM/dd/yyyy HH:mm:ss.SSS"); 2、距离 2000年1月1日 45 天之后的某天在下一个月的当前周的最后一天的日期 Joda123DateTime dateTime = new DateTime(2000, 1, 1, 0, 0, 0, 0);System.out.println(dateTime.plusDays(45).plusMonths(1).dayOfWeek() .withMaximumValue().toString("E MM/dd/yyyy HH:mm:ss.SSS"); 结果 Sun 03/19/2000 00:00:00.000 文章参考： https://www.ibm.com/developerworks/cn/java/j-jodatime.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[微服务场景下性能问题排查神器之xrebel]]></title>
    <url>%2F2018%2F03%2F19%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9C%BA%E6%99%AF%E4%B8%8B%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E7%A5%9E%E5%99%A8%E4%B9%8Bxrebel%2F</url>
    <content type="text"><![CDATA[对于java应用性能跟踪其实有很多种手段，本文只是针对xrebel的使用做一些简单讲解（单体应用和微服务应用）。分布式跟踪有很多，比如zipkin等。zipkin太重，不适合开发阶段使用。本文介绍的xrebel是一个适合小团队开发时期使用的idea(Eclipse)插件。如果对zipkin想了解，可以参考dubbo分布式系统链路追踪_zipkin. xrebel下载 百度云（内含激活文件）：链接: https://pan.baidu.com/s/1qYvBDMG 密码: fefb 官方地址：https://zeroturnaround.com/software/xrebel/download/ 快速安装 下载xrebel.zip, 并解压到本地，例如：D:/xrebel 。注意路径中不要有中文不要有空格 在tomcat也好，idea,eclipse也好，修改vm 参数，添加 -javaagent:[path/to/xrebel]/xrebel.jar 配置demo idea eclipse 默认是可以试用14天的，建议支持正版，毕竟大家都是吃这行饭的。上述下载方式中百度云里下载包含破解文件。具体破解方式参考下文。 启动项目1、项目启动时控制台出现如下日志123456789101112131415Connected to the target VM, address: &apos;127.0.0.1:56732&apos;, transport: &apos;socket&apos;XRebel: Starting logging to file: C:\Users\10400\.xrebel\xrebel.log2017-12-21 15:40:16 XRebel: 2017-12-21 15:40:16 XRebel: ################################################################2017-12-21 15:40:16 XRebel: 2017-12-21 15:40:16 XRebel: XRebel 3.1.3 (201607291040)2017-12-21 15:40:16 XRebel: (c) Copyright ZeroTurnaround AS, Estonia, Tallinn.2017-12-21 15:40:16 XRebel: 2017-12-21 15:40:16 XRebel: For questions and support, contact xrebel@zeroturnaround.com2017-12-21 15:40:16 XRebel: 2017-12-21 15:40:16 XRebel: ################################################################2017-12-21 15:40:16 XRebel: 2017-12-21 15:40:16.719 [auth-service] [main] WARN [com.br.auth.AuthApplication] -启动demo服务2017-12-21 15:40:17.027 [auth-service] [restartedMain] WARN [com.br.auth.AuthApplication] -启动demo服务........... 2、项目页面左下角有如下图标 激活xrebel xrebel 简单使用教程打开 web 服务页面，xrebel会直接注入到你的页面中，左下角会出现xrebel的toobar，例如：http://localhost:18601。或者通过 访问服务/xrebel 打开单独页面，适用于webservice,restful 等无页面场景。]]></content>
  </entry>
  <entry>
    <title><![CDATA[音乐发烧友必备听歌神器foobar2000-可视化音乐配置]]></title>
    <url>%2F2018%2F03%2F19%2F%E9%9F%B3%E4%B9%90%E5%8F%91%E7%83%A7%E5%8F%8B%E5%BF%85%E5%A4%87%E5%90%AC%E6%AD%8C%E7%A5%9E%E5%99%A8foobar2000-%E5%8F%AF%E8%A7%86%E5%8C%96%E9%9F%B3%E4%B9%90%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言foobar2000是一种高级音频播放器。对于音乐发烧友来说应该并不陌生。本文主要介绍foobar2000结合shpeck插件实现可视化音乐。FB2K的优点大概有以下几个： 强大到没朋友的扩展性； 良好的可靠性； 方便的工具管理。 关于foobar2000本篇文章并不过多介绍，如果你是小白请你自己百度去。本篇文章主要介绍搭载了各种酷炫功能后的foorbar2000的安装及使用！ 本篇文章所使用的foobar2000是整合网上各种酷炫插件后的成品。无需特殊配置。仅需要下载压缩包，解压即可使用！ 下载本篇文章所使用的foobar2000是整合网上各种酷炫插件后的成品。无需特殊配置。仅需要下载压缩包，解压即可使用！百度云盘：链接: https://pan.baidu.com/s/1nvCCU6X 密码: fws8 安装解压后双击foobar2000.exe即可使用。 使用1、添加本地音乐。 2、酷炫插件配置及使用本文主要介绍的就是可视化插件。对于下图中声谱、声量计、峰值计、示波仪、频谱等效果，使用者点击即可查看效果，无需特殊配置。本节会着重介绍shpeck(可视化音乐插件)的配置。 2.1 频谱 2.2 可是化音乐-shpeck特别说明：由于gif仅支持5M一下，所以一下示例做了压缩处理，真实效果绝对流畅。shpeck 配置过程： 写在最后的话1、本文所使用软件仅限于windows。2、有问题请留言。3、更多更强大的功能等待你去发现，如有好的插件或建议请留言给我。]]></content>
  </entry>
  <entry>
    <title><![CDATA[十个实用MySQL命令及函数]]></title>
    <url>%2F2018%2F03%2F19%2F%E5%8D%81%E4%B8%AA%E5%AE%9E%E7%94%A8MySQL%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前言今天介绍一些MySQL常用的实用命令，都是一些比较简单的命令。已经知道的朋友，就当是巩固吧，不知道的童鞋，可以好好在自己的机器上，练习下。 0. 显示数据库命令：show databases。作用：列出当前数据库服务器中所有的数据库。例子： 123456789101112mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || andyqian || mydata || mysql || performance_schema || sys |+--------------------+6 rows in set (0.00 sec) 1. 切换数据库命令: use database_name。作用: 切换数据库。例子: 12mysql&gt; use andyqian;Database changed 2. 显示数据库中的所有表命令: show tables。作用: 显示数据库中的所有表。例子: 12345678910mysql&gt; show tables;+--------------------+| Tables_in_andyqian |+--------------------+| hit_counter || t_base_01 || t_base_data || t_base_user |+--------------------+4 rows in set (0.00 sec) 3. 显示表中的所有列命令:show full columns tables_name;作用: 显示表中所有列信息。例子: 12345678910111213141516171819202122mysql&gt; show full columns from t_base_data\G;*************************** 1\. row *************************** Field: id Type: bigint(20) Collation: NULL Null: NO Key: PRI Default: NULL Extra: auto_incrementPrivileges: select,insert,update,references Comment: *************************** 2\. row *************************** Field: content Type: json Collation: NULL Null: YES Key: Default: NULL Extra: Privileges: select,insert,update,references Comment: 2 rows in set (0.01 sec) 注意：我这里使用终端直接连接数据库，\G为按列格式化显示。如果使用Navicat工具，则为下面这样。 4. 查看MySQL版本命令：select version(); 。作用：查看服务器版本。例子： 1234567mysql&gt; select version();+-----------+| version() |+-----------+| 5.7.20 |+-----------+1 row in set (0.00 sec) 注意：查看MySQL版本是一件非常重要的事情，比如：MySQL5.6之前就不支持Online DDL，MySQL 5.7.8 之前就不支持JSON数据类型。 5. 查看当前用户命令：select current_user();作用：显示当前登录用户例子： 1234567mysql&gt; select current_user();+----------------+| current_user() |+----------------+| root@localhost |+----------------+1 row in set (0.00 sec) 注意：上面是仅仅是为了演示，在生产环境中，不建议直接使用root用户，建议的是：建一个新用户连接数据库，以及做好权限分配，至于为什么？这里就不一一展开了，下次单独拧出来写一篇文章。 6. 显示单表信息命令：show table status like table_name。作用：显示表详细信息。例子： 123456789101112131415161718192021mysql&gt; show table status like &quot;t_base_data&quot;\G;*************************** 1\. row *************************** Name: t_base_data Engine: InnoDB Version: 10 Row_format: Dynamic Rows: 2 Avg_row_length: 8192 Data_length: 16384Max_data_length: 0 Index_length: 0 Data_free: 0 Auto_increment: 3 Create_time: 2017-12-08 00:30:03 Update_time: NULL Check_time: NULL Collation: utf8_unicode_ci Checksum: NULL Create_options: Comment: 1 row in set (0.00 sec) 注意：该命令详细的展示了表的信息，其中包括表名，表的存储引擎，版本，数据长度，索引长度，创建时间，修改时间等等。 7. 显示进程数命令： show processlist。作用：显示正在操作数据库的进程数。例子： 12345678910111213141516171819mysql&gt; show processlist\G;*************************** 1\. row *************************** Id: 6 User: root Host: localhost db: andyqianCommand: Query Time: 0 State: starting Info: show processlist*************************** 2\. row *************************** Id: 7 User: root Host: localhost:46612 db: NULLCommand: Sleep Time: 1439 State: Info: NULL 注意：该命令显示了所有连接数据库的进程数，其中就包括，用户,主机，连接的数据库等信息。 8. 显示索引命令：show index from table_name;作用：显示表中的所有索引。例子： 123456789101112131415161718192021222324252627282930mysql&gt; show index from t_base_data\G;*************************** 1\. row *************************** Table: t_base_data Non_unique: 0 Key_name: PRIMARY Seq_in_index: 1 Column_name: id Collation: A Cardinality: 2 Sub_part: NULL Packed: NULL Null: Index_type: BTREE Comment: Index_comment: *************************** 2\. row *************************** Table: t_base_data Non_unique: 1 Key_name: idx_created_at Seq_in_index: 1 Column_name: created_at Collation: A Cardinality: 1 Sub_part: NULL Packed: NULL Null: YES Index_type: BTREE Comment: Index_comment: 2 rows in set (0.00 sec) 注意：这里显示了表中的索引信息，从这里就能看出建了哪些索引，联合索引的顺序。对索引不了解的童鞋，可以看看这篇文章《写会MySQL索引》。 9. 查看执行计划命令：explain 查询语句。作用：查看查询语句的执行情况，常用于SQL优化。例子： 123456789101112131415mysql&gt; explain select * from t_base_user where created_at&gt;&quot;2017-12-09&quot;\G;*************************** 1\. row *************************** id: 1 select_type: SIMPLE table: t_base_user partitions: NULL type: ALLpossible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 1 filtered: 100.00 Extra: Using where1 row in set, 1 warning (0.00 sec) 注意: 查看SQL的执行计划是一个好习惯，无论是新手，还是老司机，都应该养成这个习惯。上面这个执行计划还读的懂吗？如果不懂，可以回顾这篇文章《读懂MySQL执行计划》 最后上面列出了一些SQL命令，在实际工作中，非常实用。其实工作中用到的SQL命令远远不止这些，下次我们再写。 函数0. 显示当前时间命令：select now()。作用: 显示当前时间。应用场景: 创建时间，修改时间等默认值。例子： 1234567mysql&gt; select now();+---------------------+| now() |+---------------------+| 2017-12-27 20:14:56 |+---------------------+1 row in set (0.00 sec) 1. 字符长度命令：select char_length(&#39;andyqan&#39;)。作用: 显示指定字符长度。应用场景: 查看字符长度时。例子： 1234567mysql&gt; select char_length(&apos;andyqian&apos;);+-------------------------+| char_length(&apos;andyqian&apos;) |+-------------------------+| 8 |+-------------------------+1 row in set (0.00 sec) 2. 日期格式化命令：select date_format(now(),&#39;%y-%m-%d)。作用：格式化日期。应用场景：格式化日期时。例子： 1234567mysql&gt; select date_format(now(),&apos;%y-%m-%d&apos;);+-------------------------------+| date_format(now(),&apos;%y-%m-%d&apos;) |+-------------------------------+| 17-12-28 |+-------------------------------+1 row in set (0.00 sec) 这里支持的格式有:%y：表示年(两位数)，例如: 17 年。%Y：表示4位数中的年，例如: 2017年%m：表示月(1-12)%d: 表示月中的天%H: 小时(0-23)%i: 分钟 (0-59)%s: 秒 (0-59) 年月日时分秒: %y-%m-%d %H:%i:%s，如下所示： 1234567mysql&gt; select DATE_FORMAT(now(),&apos;%y-%m-%d %H:%i:%s&apos;);+----------------------------------------+| DATE_FORMAT(now(),&apos;%y-%m-%d %H:%i:%s&apos;) |+----------------------------------------+| 17-12-27 20:28:54 |+----------------------------------------+1 row in set (0.00 sec) 3. 添加/减少日期时间命令：DATE_ADD(date,interval expr unit)DATE_SUB(date,interval expr unit)作用: 增加/减少日期时间应用场景：当前时间的前一天，前几分钟。 常用于数据统计。例子： 1234567mysql&gt; select date_add(now(),interval 1 day);+--------------------------------+| date_add(now(),interval 1 day) |+--------------------------------+| 2017-12-28 20:10:17 |+--------------------------------+1 row in set (0.00 sec) 其中Date表示日期格式，其中就包括: 如2017-12-27，now() 等格式。expr：表示数量。unit：表示单位，支持毫秒(microsecond)，秒(second)，小时(hour)，天(day)，周(week)，年(year)等。 4. 类型转换命令： CAST(expr AS type)作用: 主要用于显示类型转换应用场景：显示类型转换例子： 1234567mysql&gt; select cast(18700000000 as char);+---------------------------+| cast(18700000000 as char) |+---------------------------+| 18700000000 |+---------------------------+1 row in set (0.00 sec) 需要注意的是，其中type支持的不是全部基本数据类型，支持的详细类型，请参考之前的文章《谈谈MySQL显示类型转换》。 5. 加密函数命令： md5(data)作用: 用于加密数据应用场景：加密，一些隐私数据，例如银行卡号，身份证等需要存储密文，(当然，不建议使用数据库层加密，应该在应用层加密)例子： 1234567mysql&gt; select md5(&quot;andyqian&quot;);+----------------------------------+| md5(&quot;andyqian&quot;) |+----------------------------------+| 8a6f60827608e7f1ae29d1abcecffc3a |+----------------------------------+1 row in set (0.00 sec) 注意事项: 如果目前你们数据库中的数据还是明文，此时可以使用数据库加密算法进行加密。 例如: (仅做演示): 1update t_base_user set name=md5(name),updated_time=now() where id=1; 支持的加密函数有: md5() des_encrypt(加密) / des_decrypt(解密); sha1() password() 等等 这里不再一一介绍，有兴趣的同学，可以移步至官网进行详细了解。 6. 字符串连接命令： concat(str,str2,str3)作用：拼接字符串应用场景：拼接字符串，例如在某些字段上同一加上指定字符串。例子： 1234567mysql&gt; select concat(&quot;andy&quot;,&quot;qian&quot;);+-----------------------+| concat(&quot;andy&quot;,&quot;qian&quot;) |+-----------------------+| andyqian |+-----------------------+1 row in set (0.00 sec) 该函数平时也还是用的比较多的，基本上场景是，在某些数据上，加上特定的字符串。方法如下: 7. JSON函数(5.7版本才支持) 命令：json_object(函数)作用：转换json字符串应用场景：指定数据转换json字符串例子： 1234567mysql&gt; select json_object(&quot;name&quot;,&quot;andyqian&quot;,&quot;database&quot;,&quot;MySQL&quot;);+---------------------------------------------------+| json_object(&quot;name&quot;,&quot;andyqian&quot;,&quot;database&quot;,&quot;MySQL&quot;) |+---------------------------------------------------+| &#123;&quot;name&quot;: &quot;andyqian&quot;, &quot;database&quot;: &quot;MySQL&quot;&#125; |+---------------------------------------------------+1 row in set (0.00 sec) 其中包括json_array: 1234567mysql&gt; select json_array(&quot;name&quot;,&quot;andyqian&quot;,&quot;database&quot;,&quot;MySQL&quot;);+--------------------------------------------------+| json_array(&quot;name&quot;,&quot;andyqian&quot;,&quot;database&quot;,&quot;MySQL&quot;) |+--------------------------------------------------+| [&quot;name&quot;, &quot;andyqian&quot;, &quot;database&quot;, &quot;MySQL&quot;] |+--------------------------------------------------+1 row in set (0.00 sec) 判断是否为json字符串的json_valid(): 1select json_valid(&apos;&#123;&quot;name&quot;: &quot;andyqian&quot;, &quot;database&quot;: &quot;MySQL&quot;&#125;&apos;); 其中为有效json字符串时为1。无效json字符串时为0.还有很多方法，不再一一演示。 8. 聚合函数命令： sum()，count()，avg()，max()，min()作用：统计，求平均值，最大，最小值应用场景：这类函数非常常见，主要用于数据统计，在SQL优化方面，也适用。例子： 1234567mysql&gt; select max(id) from t_base_user;+---------+| max(id) |+---------+| 2 |+---------+1 row in set (0.00 sec) 这里有个小技巧，如果主键是有序递增的，当需要有多少用户时，可以使用max(id)来代替count(*)函数。 9. distinct()命令： distinct作用：去重应用场景：需要统计类型，状态，计算区分度时。例子： 1234567mysql&gt; select count(distinct(name))/count(*) from t_base_user;+--------------------------------+| count(distinct(name))/count(*) |+--------------------------------+| 0.6667 |+--------------------------------+1 row in set (0.00 sec) 上述为计算区分度的例子，如有不明白的，可以参考之前的文章《写会MySQL索引》 附录（mysql 函数大全）：一、数学函数 ABS(x) 返回x的绝对值BIN(x) 返回x的二进制（OCT返回八进制，HEX返回十六进制）CEILING(x) 返回大于x的最小整数值EXP(x) 返回值e（自然对数的底）的x次方FLOOR(x) 返回小于x的最大整数值GREATEST(x1,x2,…,xn)返回集合中最大的值LEAST(x1,x2,…,xn) 返回集合中最小的值LN(x) 返回x的自然对数LOG(x,y)返回x的以y为底的对数MOD(x,y) 返回x/y的模（余数）PI()返回pi的值（圆周率）RAND()返回０到１内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。ROUND(x,y)返回参数x的四舍五入的有y位小数的值SIGN(x) 返回代表数字x的符号的值SQRT(x) 返回一个数的平方根TRUNCATE(x,y) 返回数字x截短为y位小数的结果 二、聚合函数(常用于GROUP BY从句的SELECT查询中) AVG(col)返回指定列的平均值COUNT(col)返回指定列中非NULL值的个数MIN(col)返回指定列的最小值MAX(col)返回指定列的最大值SUM(col)返回指定列的所有值之和GROUP_CONCAT(col) 返回由属于一组的列值连接组合而成的结果 三、字符串函数ASCII(char)返回字符的ASCII码值BIT_LENGTH(str)返回字符串的比特长度CONCAT(s1,s2…,sn)将s1,s2…,sn连接成字符串CONCAT_WS(sep,s1,s2…,sn)将s1,s2…,sn连接成字符串，并用sep字符间隔INSERT(str,x,y,instr) 将字符串str从第x位置开始，y个字符长的子串替换为字符串instr，返回结果FIND_IN_SET(str,list)分析逗号分隔的list列表，如果发现str，返回str在list中的位置LCASE(str)或LOWER(str) 返回将字符串str中所有字符改变为小写后的结果LEFT(str,x)返回字符串str中最左边的x个字符LENGTH(s)返回字符串str中的字符数LTRIM(str) 从字符串str中切掉开头的空格POSITION(substr,str) 返回子串substr在字符串str中第一次出现的位置QUOTE(str) 用反斜杠转义str中的单引号REPEAT(str,srchstr,rplcstr)返回字符串str重复x次的结果REVERSE(str) 返回颠倒字符串str的结果RIGHT(str,x) 返回字符串str中最右边的x个字符RTRIM(str) 返回字符串str尾部的空格STRCMP(s1,s2)比较字符串s1和s2TRIM(str)去除字符串首部和尾部的所有空格UCASE(str)或UPPER(str) 返回将字符串str中所有字符转变为大写后的结果 四、日期和时间函数CURDATE()或CURRENT_DATE() 返回当前的日期CURTIME()或CURRENT_TIME() 返回当前的时间DATE_ADD(date,INTERVAL int keyword)返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化),如：SELECTDATE_ADD(CURRENT_DATE,INTERVAL 6 MONTH);DATE_FORMAT(date,fmt) 依照指定的fmt格式格式化日期date值DATE_SUB(date,INTERVAL int keyword)返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化),如：SELECTDATE_SUB(CURRENT_DATE,INTERVAL 6 MONTH);DAYOFWEEK(date) 返回date所代表的一星期中的第几天(1~7)DAYOFMONTH(date) 返回date是一个月的第几天(1~31)DAYOFYEAR(date) 返回date是一年的第几天(1~366)DAYNAME(date) 返回date的星期名，如：SELECT DAYNAME(CURRENT_DATE);FROM_UNIXTIME(ts,fmt) 根据指定的fmt格式，格式化UNIX时间戳tsHOUR(time) 返回time的小时值(0~23)MINUTE(time) 返回time的分钟值(0~59)MONTH(date) 返回date的月份值(1~12)MONTHNAME(date) 返回date的月份名，如：SELECT MONTHNAME(CURRENT_DATE);NOW() 返回当前的日期和时间QUARTER(date) 返回date在一年中的季度(1~4)，如SELECT QUARTER(CURRENT_DATE);WEEK(date) 返回日期date为一年中第几周(0~53)YEAR(date) 返回日期date的年份(1000~9999)一些示例： 复制代码 代码如下: 获取当前系统时间：SELECT FROM_UNIXTIME(UNIX_TIMESTAMP());SELECT EXTRACT(YEAR_MONTH FROM CURRENT_DATE);SELECT EXTRACT(DAY_SECOND FROM CURRENT_DATE);SELECT EXTRACT(HOUR_MINUTE FROM CURRENT_DATE); 返回两个日期值之间的差值(月数)：SELECT PERIOD_DIFF(200302,199802); 在Mysql中计算年龄：SELECT DATE_FORMAT(FROM_DAYS(TO_DAYS(NOW())-TO_DAYS(birthday)),’%Y’)+0 AS age FROM employee;这样，如果Brithday是未来的年月日的话，计算结果为0。下面的SQL语句计算员工的绝对年龄，即当Birthday是未来的日期时，将得到负值。SELECT DATE_FORMAT(NOW(), ‘%Y’) - DATE_FORMAT(birthday, ‘%Y’) -(DATE_FORMAT(NOW(), ‘00-%m-%d’) &lt;DATE_FORMAT(birthday, ‘00-%m-%d’)) AS age from employee 五、加密函数AES_ENCRYPT(str,key) 返回用密钥key对字符串str利用高级加密标准算法加密后的结果，调用AES_ENCRYPT的结果是一个二进制字符串，以BLOB类型存储AES_DECRYPT(str,key) 返回用密钥key对字符串str利用高级加密标准算法解密后的结果DECODE(str,key) 使用key作为密钥解密加密字符串strENCRYPT(str,salt) 使用UNIXcrypt()函数，用关键词salt(一个可以惟一确定口令的字符串，就像钥匙一样)加密字符串strENCODE(str,key) 使用key作为密钥加密字符串str，调用ENCODE()的结果是一个二进制字符串，它以BLOB类型存储MD5() 计算字符串str的MD5校验和PASSWORD(str) 返回字符串str的加密版本，这个加密过程是不可逆转的，和UNIX密码加密过程使用不同的算法。SHA() 计算字符串str的安全散列算法(SHA)校验和示例： 复制代码 代码如下: SELECT ENCRYPT(‘root’,’salt’);SELECT ENCODE(‘xufeng’,’key’);SELECT DECODE(ENCODE(‘xufeng’,’key’),’key’);#加解密放在一起SELECT AES_ENCRYPT(‘root’,’key’);SELECT AES_DECRYPT(AES_ENCRYPT(‘root’,’key’),’key’);SELECT MD5(‘123456’);SELECT SHA(‘123456’); 六、控制流函数MySQL有4个函数是用来进行条件操作的，这些函数可以实现SQL的条件逻辑，允许开发者将一些应用程序业务逻辑转换到数据库后台。 MySQL控制流函数： CASE WHEN[test1] THEN [result1]…ELSE [default] END如果testN是真，则返回resultN，否则返回defaultCASE [test] WHEN[val1] THEN [result]…ELSE [default]END 如果test和valN相等，则返回resultN，否则返回defaultIF(test,t,f) 如果test是真，返回t；否则返回fIFNULL(arg1,arg2) 如果arg1不是空，返回arg1，否则返回arg2NULLIF(arg1,arg2) 如果arg1=arg2返回NULL；否则返回arg1这些函数的第一个是IFNULL()，它有两个参数，并且对第一个参数进行判断。如果第一个参数不是NULL，函数就会向调用者返回第一个参数；如果是NULL,将返回第二个参数。 如：SELECT IFNULL(1,2), IFNULL(NULL,10),IFNULL(4*NULL,’false’);NULLIF()函数将会检验提供的两个参数是否相等，如果相等，则返回NULL，如果不相等，就返回第一个参数。 如：SELECT NULLIF(1,1),NULLIF(‘A’,’B’),NULLIF(2+3,4+1);和许多脚本语言提供的IF()函数一样，MySQL的IF()函数也可以建立一个简单的条件测试，这个函数有三个参数，第一个是要被判断的表达式，如果表达式为真，IF()将会返回第二个参数，如果为假，IF()将会返回第三个参数。 如：SELECTIF(1&lt;10,2,3),IF(56&gt;100,’true’,’false’);IF()函数在只有两种可能结果时才适合使用。然而，在现实世界中，我们可能发现在条件测试中会需要多个分支。在这种情况下，MySQL提供了CASE函数，它和PHP及Perl语言的switch-case条件例程一样。CASE函数的格式有些复杂，通常如下所示： 复制代码 代码如下: CASE [expression to be evaluated]WHEN [val 1] THEN [result 1]WHEN [val 2] THEN [result 2]WHEN [val 3] THEN [result 3]……WHEN [val n] THEN [result n]ELSE [default result]END 这里，第一个参数是要被判断的值或表达式，接下来的是一系列的WHEN-THEN块，每一块的第一个参数指定要比较的值，如果为真，就返回结果。所有的WHEN-THEN块将以ELSE块结束，当END结束了所有外部的CASE块时，如果前面的每一个块都不匹配就会返回ELSE块指定的默认结果。如果没有指定ELSE块，而且所有的WHEN-THEN比较都不是真，MySQL将会返回NULL。CASE函数还有另外一种句法，有时使用起来非常方便，如下：CASE 复制代码 代码如下: WHEN [conditional test 1] THEN [result 1]WHEN [conditional test 2] THEN [result 2]ELSE [default result]END 这种条件下，返回的结果取决于相应的条件测试是否为真。示例： 复制代码 代码如下: mysql&gt;SELECT CASE ‘green’ WHEN ‘red’ THEN ‘stop’ WHEN ‘green’ THEN ‘go’ END;SELECT CASE 9 WHEN 1 THEN ‘a’ WHEN 2 THEN ‘b’ ELSE ‘N/A’ END;SELECT CASE WHEN (2+2)=4 THEN ‘OK’ WHEN(2+2)&lt;&gt;4 THEN ‘not OK’ END ASSTATUS;SELECT Name,IF((IsActive = 1),’已激活’,’未激活’) AS RESULT FROMUserLoginInfo;SELECT fname,lname,(math+sci+lit) AS total,CASE WHEN (math+sci+lit) &lt; 50 THEN ‘D’WHEN (math+sci+lit) BETWEEN 50 AND 150 THEN ‘C’WHEN (math+sci+lit) BETWEEN 151 AND 250 THEN ‘B’ELSE ‘A’ ENDAS grade FROM marks;SELECT IF(ENCRYPT(‘sue’,’ts’)=upass,’allow’,’deny’) AS LoginResultFROM users WHERE uname = ‘sue’;#一个登陆验证 七、格式化函数DATE_FORMAT(date,fmt) 依照字符串fmt格式化日期date值FORMAT(x,y) 把x格式化为以逗号隔开的数字序列，y是结果的小数位数INET_ATON(ip) 返回IP地址的数字表示INET_NTOA(num) 返回数字所代表的IP地址TIME_FORMAT(time,fmt) 依照字符串fmt格式化时间time值其中最简单的是FORMAT()函数，它可以把大的数值格式化为以逗号间隔的易读的序列。示例： 复制代码 代码如下: SELECT FORMAT(34234.34323432,3);SELECT DATE_FORMAT(NOW(),’%W,%D %M %Y %r’);SELECT DATE_FORMAT(NOW(),’%Y-%m-%d’);SELECT DATE_FORMAT(19990330,’%Y-%m-%d’);SELECT DATE_FORMAT(NOW(),’%h:%i %p’);SELECT INET_ATON(‘10.122.89.47’);SELECT INET_NTOA(175790383); 八、类型转化函数为了进行数据类型转化，MySQL提供了CAST()函数，它可以把一个值转化为指定的数据类型。类型有：BINARY,CHAR,DATE,TIME,DATETIME,SIGNED,UNSIGNED示例： 复制代码 代码如下: SELECT CAST(NOW() AS SIGNED INTEGER),CURDATE()+0;SELECT ‘f’=BINARY ‘F’,’f’=CAST(‘F’ AS BINARY); 九、系统信息函数DATABASE() 返回当前数据库名BENCHMARK(count,expr) 将表达式expr重复运行count次CONNECTION_ID() 返回当前客户的连接IDFOUND_ROWS() 返回最后一个SELECT查询进行检索的总行数USER()或SYSTEM_USER() 返回当前登陆用户名VERSION() 返回MySQL服务器的版本示例： 复制代码 代码如下: SELECT DATABASE(),VERSION(),USER();SELECTBENCHMARK(9999999,LOG(RAND()PI()));#该例中,MySQL计算LOG(RAND()PI())表达式9999999次。]]></content>
  </entry>
  <entry>
    <title><![CDATA[idea常用插件分享]]></title>
    <url>%2F2018%2F03%2F19%2Fidea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[本文主要推荐几款idea常用的插件，在日常开发中不仅可以装逼，还可以适当的提升开发效率。 1、activate-power-mode根据Atom的插件activate-power-mode的效果移植到IDEA上 2、Alibaba Java Coding Guidelines 阿里巴巴编码规约插件，极力推荐 3、Background Image Plusidea背景修改插件，让你的idea与众不同，狂拽酷炫吊炸天。 4、Free Mybatis pluginmybatis 插件，让你的mybatis.xml像java代码一样编辑。 5、Grep console自定义日志颜色 6、String Manipulation强大的字符串转换工具。使用快捷键，Alt+m Toggle style (camelCase, hyphen-lowercase, HYPHEN-UPPERCASE, snake_case, SCREAMING_SNAKE_CASE, dot.case, words lowercase, Words Capitalized, PascalCase) To SCREAMING_SNAKE_CASE (or to camelCase) To snake_case (or to camelCase) To dot.case (or to camelCase) To hyphen-case (or to camelCase) To hyphen-case (or to snake_case) To camelCase (or to words) To PascalCase (or to camelCase) Capitalize selected text 7、LomBok PluginA plugin that adds first-class support for Project Lombok Features @Getter and @Setter @ToString @EqualsAndHashCode @AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor @Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog @Data @Builder @Singular @Delegate @Value @Accessors @Wither @SneakyThrows from Intellij 14.1 @val from Intellij 14.1 @var from Intellij 2016.2 @UtilityClass Lombok config system Code inspections Refactoring actions (lombok and delombok) 8、Key promoter快捷键提示插件 9、CodeGlance快速定位代码。右侧小地图。 10、Gsonformat可根据json数据快速生成java实体类 11、Properties to YAML ConverterProperties 转 YAML 格式插件 12、HighlightBracketPair 参考文章：https://juejin.im/entry/59fa8e5df265da43062a1aed]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用ApplicationEvent和Listener快速实现业务解耦]]></title>
    <url>%2F2018%2F03%2F19%2F%E4%BD%BF%E7%94%A8ApplicationEvent%E5%92%8CListener%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E8%A7%A3%E8%80%A6%2F</url>
    <content type="text"><![CDATA[ApplicationEvent以及Listener是Spring为我们提供的一个事件监听、订阅的实现，内部实现原理是观察者设计模式，设计初衷也是为了系统业务逻辑之间的解耦，提高可扩展性以及可维护性。 通过 ApplicationEvent 类和 ApplicationListener 接口来提供在 ApplicationContext 中处理事件。如果一个 bean 实现 ApplicationListener，那么每次 ApplicationEvent 被发布到 ApplicationContext 上，那个 bean 会被通知。 ###Spring 提供了以下的标准事件： 序号 |Spring 内置事件 &amp; 描述|:-:|:-||1|ContextRefreshedEvent ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在 ConfigurableApplicationContext 接口中使用 refresh() 方法来发生。||2|ContextStartedEvent当使用 ConfigurableApplicationContext 接口中的 start() 方法启动 ApplicationContext 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。||3|ContextStoppedEvent当使用 ConfigurableApplicationContext 接口中的 stop() 方法停止 ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作。||4|ContextClosedEvent当使用 ConfigurableApplicationContext 接口中的 close() 方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。||5|RequestHandledEvent这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。| 一下通过一个实例说明： 项目的整体结构如下图所示 1、构建项目123456789101112131415161718192021222324252627282930&lt;groupId&gt;com.br&lt;/groupId&gt; &lt;artifactId&gt;ListenerDemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.16&lt;/version&gt; &lt;/dependency&gt; &lt;!--test--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、创建Event事件首先注意：listener都是围绕着event来挂起的。1234567891011121314151617181920212223242526272829303132333435package com.br.event;import com.br.bean.User;import org.springframework.context.ApplicationEvent;/** * @author jackcooper * @create 2018-02-27 13:54 */public class UserRegisterEvent extends ApplicationEvent &#123; public User user; /** * * @param source 发生事件的对象 * @param user 注册用户对象 */ public UserRegisterEvent(Object source,User user) &#123; super(source); this.user = user; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 3、事件发布此部分主要在业务逻辑模块触发，主要用到ApplicationContext类以及它的publishEvent(ApplicationEvent t)方法。 1234567891011121314151617181920212223242526package com.br.service;import com.br.bean.User;import com.br.event.UserRegisterEvent;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.stereotype.Service;/** * @author jackcooper * @create 2018-02-27 14:03 */@Servicepublic class UserService &#123; @Autowired private ApplicationContext applicationContext; public void register(User user)&#123; //省略业务逻辑 //。。。。 //发布UserRegisterEvent事件 applicationContext.publishEvent(new UserRegisterEvent(this,user)); &#125; &#125; 4、创建Event事件监听第一种方式：基于EventListener注解实现 注解方式比较简单，并不需要实现任何接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.br.listener;import com.br.bean.User;import com.br.event.UserRegisterEvent;import org.springframework.context.event.EventListener;import org.springframework.stereotype.Component;/** * @author jackcooper * @create 2018-02-27 14:17 * @deprecated 方法一：注解方式比较简单，并不需要实现任何接口 排序随机 */@Componentpublic class AnnotationRegisterListener &#123; /** * 注册监听实现方法 * @param userRegisterEvent 用户注册事件 */ @EventListener public void sendEmail(UserRegisterEvent userRegisterEvent) &#123; //获取注册用户对象 User user = userRegisterEvent.getUser(); //todo //输出注册用户信息 System.out.println("发送邮件，用户名："+user.getName()+"，邮箱："+user.getEmail()); &#125; /** * 注册监听实现方法 * @param userRegisterEvent 用户注册事件 */ @EventListener public void register(UserRegisterEvent userRegisterEvent) &#123; //获取注册用户对象 User user = userRegisterEvent.getUser(); //todo //输出注册用户信息 System.out.println("1注册信息，用户名："+user.getName()+"，邮箱："+user.getEmail()); &#125;&#125; 第二种方式：实现 ApplicationListener接口 这种方式也是Spring之前比较常用的监听事件方式，在实现ApplicationListener接口时需要将监听事件作为泛型传递123456789101112131415161718192021222324252627282930package com.br.listener;import com.br.bean.User;import com.br.event.UserRegisterEvent;import org.springframework.context.ApplicationListener;import org.springframework.stereotype.Component;/** * @author jackcooper * @create 2018-02-27 14:29 * @deprecated ApplicationListener实现监听：这种方式也是Spring之前比较常用的监听事件方式，在实现ApplicationListener接口时需要将监听事件作为泛型传递，监听实现代码如下所示 */@Componentpublic class RegisterListener implements ApplicationListener&lt;UserRegisterEvent&gt; &#123; /** * 实现监听 * @param userRegisterEvent */ @Override public void onApplicationEvent(UserRegisterEvent userRegisterEvent) &#123; //获取注册用户对象 User user = userRegisterEvent.getUser(); //../省略逻辑 //输出注册用户信息 System.out.println("2注册信息，用户名："+user.getName()+"，密码："+user.getEmail()); &#125;&#125; 第三种方式：实现SmartApplicationListener接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.br.listener;import com.br.bean.User;import com.br.event.UserRegisterEvent;import com.br.service.UserService;import org.springframework.context.ApplicationEvent;import org.springframework.context.event.SmartApplicationListener;import org.springframework.stereotype.Component;/** * @author 10400 * @create 2018-02-27 15:03 * @deprecated 有序监听 */@Componentpublic class SmartRegisterListener implements SmartApplicationListener &#123; @Override public boolean supportsEventType(Class&lt;? extends ApplicationEvent&gt; aClass) &#123; //只有UserRegisterEvent监听类型才会执行下面逻辑 return aClass == UserRegisterEvent.class; &#125; @Override public boolean supportsSourceType(Class&lt;?&gt; aClass) &#123; //只有在UserService内发布的UserRegisterEvent事件时才会执行下面逻辑 return aClass == UserService.class; &#125; @Override public void onApplicationEvent(ApplicationEvent applicationEvent) &#123; //转换事件类型 UserRegisterEvent userRegisterEvent = (UserRegisterEvent) applicationEvent; //获取注册用户对象信息 User user = userRegisterEvent.getUser(); //.../完成注册业务逻辑 System.out.println("SmartRegisterListener" + user.getName()); &#125; /** * return 的数值越小证明优先级越高，执行顺序越靠前。 * @return */ @Override public int getOrder() &#123; return 10; &#125;&#125; SmartApplicationListener接口继承了全局监听ApplicationListener，并且泛型对象使用的ApplicationEvent来作为全局监听，可以理解为使用SmartApplicationListener作为监听父接口的实现，监听所有事件发布。 可以看到除了上面的方法，还提供了一个getOrder方法，这个方法就可以解决执行监听的顺序问题，return的数值越小证明优先级越高，执行顺序越靠前。 第四种方式：使用@Async实现异步监听@Aysnc其实是Spring内的一个组件，可以完成对类内单个或者多个方法实现异步调用，这样可以大大的节省等待耗时。内部实现机制是线程池任务ThreadPoolTaskExecutor，通过线程池来对配置@Async的方法或者类做出执行动作。 线程任务池配置我们创建一个ListenerAsyncConfiguration，并且使用@EnableAsync注解开启支持异步处理，具体代码如下所示： 12345678910111213141516171819202122232425@Configuration@EnableAsyncpublic class ListenerAsyncConfiguration implements AsyncConfigurer&#123; /** * 获取异步线程池执行对象 * @return */ @Override public Executor getAsyncExecutor() &#123; //使用Spring内置线程池任务对象 ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor(); //设置线程池参数 taskExecutor.setCorePoolSize(5); taskExecutor.setMaxPoolSize(10); taskExecutor.setQueueCapacity(25); taskExecutor.initialize(); return taskExecutor; &#125; @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() &#123; return null; &#125;&#125; 我们自定义的监听异步配置类实现了AsyncConfigurer接口并且实现内getAsyncExecutor方法以提供线程任务池对象的获取。我们只需要在异步方法上添加@Async注解就可以实现方法的异步调用，为了证明这一点，我们在发送邮件onApplicationEvent方法内添加线程阻塞3秒，修改后的代码如下所示： 12345678910111213141516171819/** * supportsEventType &amp; supportsSourceType 两个方法返回true时调用该方法执行业务逻辑 * @param applicationEvent 具体监听实例，这里是UserRegisterEvent */ @Override @Async public void onApplicationEvent(ApplicationEvent applicationEvent) &#123; try &#123; Thread.sleep(3000);//静静的沉睡3秒钟 &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; //转换事件类型 UserRegisterEvent userRegisterEvent = (UserRegisterEvent) applicationEvent; //获取注册用户对象信息 UserBean user = userRegisterEvent.getUser(); System.out.println("用户："+user.getName()+"，注册成功，发送邮件通知。"); &#125; 文章参考https://www.jianshu.com/p/4359dd4b36a6]]></content>
  </entry>
  <entry>
    <title><![CDATA[在java Web项目中处理前后端日期字段自动匹配绑定]]></title>
    <url>%2F2018%2F03%2F19%2F%E5%9C%A8java-Web%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A4%84%E7%90%86%E5%89%8D%E5%90%8E%E7%AB%AF%E6%97%A5%E6%9C%9F%E5%AD%97%E6%AE%B5%E8%87%AA%E5%8A%A8%E5%8C%B9%E9%85%8D%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[在java开发中，经常会遇到前后端交互日期格式，一般我们都会用日期格式化来处理，但时间久了，你是否感觉到繁琐而且冗余呢，本文给出一种全新的解决思路。通过正则提取出日期数字，自动将前端传的日期字符串绑定到对象的日期格式属性上去，省去一切繁琐步骤。闲话少说，文归正传。 #定义BaseController 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public class BaseController implements ServletContextAware&#123;/** * 日志 **/ protected final Logger log = LoggerFactory.getLogger(BaseController.class); public HttpServletRequest request; public HttpServletResponse response; public HttpSession session; public ServletContext application; /** * 文件 **/ @Autowired(required = false) protected MultipartResolver multipartResolver; /** * @param code * @return */ public static String respJson(CodeEnum code) &#123; return respJson(code, null); &#125; /** * @param code * @param data * @return */ public static String respJson(CodeEnum code, Object data) &#123; JSONObject jsono = new JSONObject(); jsono.put("code", code.getCode()); jsono.put("message", code.getMessage()); if (data != null) &#123; jsono.put("data", data); &#125; return jsono.toJSONString(); &#125; /** * * @param code 错误码 * @param message 内容 * @return */ public static String respJson(String code , String message ) &#123; return respJson(code,message,null); &#125; /** * * @param code * @param message * @param data * @return */ public static String respJson(String code , String message , Object data)&#123; JSONObject jsono = new JSONObject(); jsono.put("code",code); jsono.put("message",message); if (data != null) &#123; jsono.put("data", data); &#125; return JSON.toJSONString(jsono); &#125; @ModelAttribute public void setReqAndRes(HttpServletRequest request, HttpServletResponse response) &#123; this.request = request; this.response = response; this.session = request.getSession(); &#125; public void setServletContext(ServletContext arg0) &#123; this.application = arg0; &#125; /** * 获取传递过来的参数 */ public String getParameter(String key) &#123; return request.getParameter(key); &#125; /** * 分页对象 */ public &lt;T&gt; Page&lt;T&gt; getPage(Class&lt;T&gt; clazz) &#123; Page&lt;T&gt; page = new Page&lt;T&gt;(); String pageNo = getParameter("pageNo"); String pageSize = getParameter("pageSize"); pageNo = pageNo == null || "".equals(pageNo) ? "1" : pageNo; pageSize = pageSize == null || "".equals(pageSize) ? "10" : pageSize; page.setSearchCount(true); page.setSize(Integer.valueOf(pageSize)); page.setCurrent((Integer.valueOf(pageNo))); return page; &#125; protected String redirectOuter(String url) &#123; return "redirect:" + url; &#125; /** * binder用于bean属性的设置 */ @InitBinder public void initBinder(WebDataBinder binder) &#123; binder.registerCustomEditor(Date.class, new DateEditor()); binder.registerCustomEditor(String.class, new StringEscapeEditor()); &#125; /** * 获取传递过来的str参数,并给默认值 */ public String getStrParameter(String key, String defaultValue) &#123; String str = getParameter(key); if (org.apache.commons.lang3.StringUtils.isEmpty(str)) &#123; return defaultValue; &#125; return str.trim(); &#125;&#125; 上述代码中initBinder方法上添加了一个@InitBinder注解，该方法会在请求时被调用，改方法中有个DateEditor类，日期的处理就是在这个里处理完的。 DateEditor类12345678910111213141516171819202122232425262728293031323334353637class DateEditor extends PropertyEditorSupport &#123; @Override public void setAsText(String text) throws IllegalArgumentException &#123; if (StringUtils.isEmpty(text)) &#123; return; &#125; text = text.trim(); Pattern pattern = Pattern.compile("[^0-9]"); Matcher matcher = pattern.matcher(text); text = matcher.replaceAll(""); int length = text.length(); Date date; switch(length)&#123; case 14: date = DateTime.parse(text,DateTimeFormat.forPattern("yyyyMMddHHmmss")).toDate(); break; case 12: date = DateTime.parse(text,DateTimeFormat.forPattern("yyyyMMddHHmm")).toDate(); break; case 10: date = DateTime.parse(text,DateTimeFormat.forPattern("yyyyMMddHH")).toDate(); break; case 8: date = DateTime.parse(text,DateTimeFormat.forPattern("yyyyMMdd")).toDate(); break; case 6: date = DateTime.parse(text,DateTimeFormat.forPattern("yyyyMM")).toDate(); break; case 4: date = DateTime.parse(text,DateTimeFormat.forPattern("yyyy")).toDate(); break; default: return; &#125; setValue(date); &#125;&#125; #如何使用上面准备完成后，在需要用到的controller中继承BaseController即可！一般网上的例子仅支持如下格式的日期： yyyyMMdd HH:mm:ss yyyyMMdd HH:mm yyyyMMdd HH yyyyMMdd yyyyMM yyyy本文的方法，支持包含14、12、10、8、6、4个数字的所有字符串。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java技术栈2017年度精选干货总结]]></title>
    <url>%2F2018%2F03%2F16%2FJava%E6%8A%80%E6%9C%AF%E6%A0%882017%E5%B9%B4%E5%BA%A6%E7%B2%BE%E9%80%89%E5%B9%B2%E8%B4%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本年度的分享知识图谱 看完是不是有点蒙逼了？没关系！ 小猿整理了年度精选排名，干货不容错过。 [图片上传失败…(image-af1ba3-1520503503952)] 往期精彩回顾1，架构设计&amp;分布式技术 TOP 10如何设计一个安全的登录流程 分布式服务防雪崩熔断器，Hystrix理论+实战 17张图揭密支付宝系统架构 8条关于Web前端性能的优化建议 分布式Session共享解决方案 接口限流算法：漏桶算法&amp;令牌桶算法 RateLimit–使用guava来做接口限流 34张架构史上最全技术知识图谱 悲观锁和乐观锁详解 服务高可用：幂等性设计 分布式系统架构CAP理论 2，Java面试题 TOP 102017派卧底去阿里、京东、美团、滴滴带回来的面试题及答案 阿里高级Java面试题（70道，带详细答案） 史上最全Spring面试题汇总 去BAT面试完的Mysql面试题总结 通往大神之路，百度Java面试题前200页 精选30道Java多线程面试题 Dubbo面试题锦集 Zookeeper面试题锦集 10道腾讯的Java面试题 2017一季度JAVA面试题锦集 3，Java核心技术TOP 10类、变量、块、构造器、继承初始化顺序，终极解答 Java内存泄漏介绍 一张图搞清楚Java异常机制 事务隔离级别和传播机制 金融系统中正确的金额计算及存储方式 JVM运行时区域详解 关于Java序列化你应该知道的一切 Java高级进阶：自定义ClassLoader 深入浅出Java类加载机制 深入理解CAS算法原理 4，Java多线程TOP 10线程池全面解析 几种线程安全的Map解析 实现java多线程的3种方式 多线程并发神器ThreadLocal Java多线程sleep和wait的区别 Java多线程神器：join使用及原理 一张图弄懂java线程的状态和生命周期 并发控制循环栅栏CyclicBarrier 并发控制倒计时器CountDownLatch volatile关键字解析 5，MavenTOP 10Maven的私库搭建及使用 Maven如何发布jar包到Nexus私库 Maven三种仓库详解 Maven依赖范围、传递、排除 Maven依赖继承与聚合 Maven区分不同环境配置文件 Maven常用命令详情 Maven依赖classifier元素妙用 Maven主配置POM文件解析 Maven集成eclipse各种操作 6，Spring TOP 10Spring的核心模块解析 Spring Bean的完整生命周期图 Spring AOP注解怎么用会失效 Spring Import配置文件使用占位符 Spring Bean - Scope详解 获取Application Context的几种方式 Spring开启方法异步执行 Spring快速开启计划任务 Spring Aware容器感知技术 Spring Enable*高级应用及原理 7，Spring BootTOP 10Spring Boot开启的2种方式 Spring Boot Starters启动器 Spring Boot自动配置原理、实战 Spring Boot国际化支持 Spring Boot核心配置 Spring Boot功能实战 Spring Boot读取配置的几种方式 Spring Boot Runner启动器 Spring Boot实现热部署 Spring Boot日志集成 8，Spring CloudTOP 10Spring Cloud和Dubbo的对比 Spring Cloud配置中心高可用搭建 Spring Cloud配置中心客户端读取配置 Spring Cloud配置中心内容加密 Spring Cloud动态刷新配置信息 Spring Cloud注册中心高可用搭建 Spring Cloud服务安全连接 Spring Cloud Eureka自我保护机制 9，开源项目推荐 TOP 10Mycat - 数性能最好的开源数据库中间件 GitHub上11月份最热门的Java项目 CAT -大 众点评Java开发实时应用监控平台 Disconf - 百度分布式配置管理平台 Cobar - 系型数据的分布式处理系统 HikariCP－史上最快速的连接池 阿里巴巴，排行前10的开源项目 腾讯，排行前10的开源项目 10，分享书籍＆视频教程TOP 10史上最全Spring Boot全套视频教程 分布式架构设计高级视频教程 进阶Java架构师必看的15本书 高级Java必看的10本书 Dubbo系列全套视频教程 Hadoop全套视频教程 Jenkins持续集成系列教程 2018年关于区块链技术的10本书 2017年Java10本经典好书推荐 阿里双11背后的技术两本书籍 文章来自：https://www.jianshu.com/p/3bd2eb564909]]></content>
  </entry>
  <entry>
    <title><![CDATA[搭建hexo博客]]></title>
    <url>%2F2018%2F03%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[hexo是一款基于Node.js的静态博客框架。hexo在npm官网上是这样介绍自己的A fast, simple &amp; powerful blog framework, powered by Node.js。在尝试使用hexo之前，请各位务必完成以下几点： 安装node.js 安装Git 会使用Git 拥有GitHub账号 下载和安装hexo 用管理员权限打开Git bash并输入npm install hexo-cli -g 在D盘新建一个空文件夹名为hexo 在Git Bash中进入hexo文件夹后输入$ hexo init 在win10中如意出现找不到hexo命令，此时需要找到hexo.cmd文件夹路径，添加到系统变量Path最后，然后再执行该命令即可成功。 部署至github在部署至github前先新建一个仓库，如blog。安装hexo-deployer-git： 1$ npm install hexo-deployer-git --save 修改_config.yml文件 1234deploy: type: git repository: &lt;repository url&gt; branch: master 生成静态文件并发布 1$ hexo g -d 注：如果在之前你有生成ssh公钥，那么就可以直接提交上去，如果没有，则需要填写邮箱以及密码 更改主题安装主题进入hexo文件夹下输入命令 1$ git clone https://github.com/A-limon/pacman.git themes/pacman 修改_config.yml文件 1theme: pacman 现在可以运行$ hexo s命令启动服务器，在浏览器中访问地址http://localhost:4000就可以查看博客了。 hexo中文官网：https://hexo.io/zh-cn/docs/hexo配置：http://blog.csdn.net/tonydandelion2014/article/details/61615898]]></content>
      <tags>
        <tag>java</tag>
        <tag>python</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java技术栈2017年度精选干货总结]]></title>
    <url>%2FJava%E6%8A%80%E6%9C%AF%E6%A0%882017%E5%B9%B4%E5%BA%A6%E7%B2%BE%E9%80%89%E5%B9%B2%E8%B4%A7%E6%80%BB%E7%BB%93%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
